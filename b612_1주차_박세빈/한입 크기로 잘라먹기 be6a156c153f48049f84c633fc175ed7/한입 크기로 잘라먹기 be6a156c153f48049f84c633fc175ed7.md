# 한입 크기로 잘라먹기

# Section 1 - JS 기본

## JS는 무엇일까

- 웹사이트는 HTML, CSS , Javascript 3가지 언어로 만들어진다.

HTML - 요소들의 배치와 내용을 기술하는 언어 , 색이나 크기 등의 디자인 X

CSS - 색, 크기, 애니메이션 등을 정의하는 스타일링을 위한 언어

Javascript - 웹사이트에 활력을 부여하는 언어 , 경고창을 띄우거나 서버로부터 데이터를 받아오거나 전송하는 역할 

- JS가 실행되는 곳(Runtime)  : Safari, Firefox, Chrom, Edge, Opera와 같은 js 엔진이 포함된 웹 브라우저 (Internet Explorer은 지양)

## Hello World

```jsx
console.log('Hello World')
```

## 변수와 상수

변수

```jsx
let age = 25;  //변수 선언
console.log(age); // 콘솔에 25가 뜸

age = 30;
console.log(age) // 콘솔에 30이 뜸

//변수명에는 기호를 사용할 수 없음.(_와 $제외)
//변수명은 숫자가 아닌 문자로 시작해야함 
//예약어는 변수명으로 사용할 수 없음 (ex : if)

var age = 25;
console.log(age)

var age = 30;
consolog.log(age) 
//위 코드와 동일하게 동작 but, let은 변수를 중복해서 선언하는 것을 허용하지 않고, var는 중복 선언을 허용한다.
//코드가 길어지는 경우 변수명의 중복으로 인한 에러의 위험이 있다.
```

상수

```jsx
const age = 25;
console.log(age);

age = 30; //에러 발생 상수는 선언 이후에 값을 바꿀 수 없음
// 따라서 선언과 동시에 초기화가 이루어져야 함.
```

## 자료형과 형 변환

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled.png)

Primitive Data Type (원시 타입) : 한 번에 하나의 값만 가질 수 있음. 하나의 고정된 저장 공간 이용

JS에는 5가지의 원시타입이 존재

```jsx

/* 숫자 */
let age = 25; // 정수

let tall = 175.9; // 실수

let inf = Infinity;

let minusInf = -Infinity;

let nan = NaN;

/* 문자 */
let name = "SEBIN";

let name2 = 'sebin';

let name3 = `sebin`;
console.log(`작성자의 이름 : ${name}`);  //template literal : 문자열로 변환해줌 
//콘솔에 작성자의 이름 : SEBIN 이렇게 찍힘

/* Boolean */
let isSwitchOff = false;
let isSwitchOn = true;

/* null */
let a = null; // 의도적으로 a가 아무 것도 담고있지 않다는 것을 명할 때 사용

/* undefined */
let variable;
console.log(variable); //콘솔에 undefined가 표시 됨.
```

형 변환

```jsx
let num1 = 12;
let num2 = 2;

console.log(num1 * num2);
//콘솔에 24가 찍힘

/////////////////////////////////
let num1 = 12;
let num2 = '2';

console.log(num1 * num2);
//마찬가지로 콘솔에 24가 찍힘 -> Js가 다른 자료형간의 연산을 수행할 때 적절한 자료형으로 변환하여 연산을 수행함. (묵시적 형변환)

console.log(num1 + num2);
//이렇게 하면 콘솔에 122가 찍힘
//14를 의도했다면 아래와 같이 수정

console.log(num1 + parseInt(num2)); //parseInt가 문자열을 숫자로 명시적 형변환
```

Non-Primitive Type ( 비원시 타입) : 한 번에 여러 개의 값을 가질 수 있음. 여러 개의 고정되지 않은 동적 공간 사용

## 연산자

대입 연산자

```jsx
let a = 1;
```

산술 연산자 

```jsx
let a = 1;
let b = 2;

console.log(a + b);

console.log(a - b);

console.log(a * b);

console.log(a / b);

console.log(a % b);

console.log(a + b);
```

연결 연산자

```jsx
let a = '1';
let b = '2';

console.log(a + b);
//콘솔에 12가 찍힘
//이 때의 형변환이 묵시적 형변환
```

복합 연산자

```jsx
let a = 4;

a = a + 10;
//이거 대신에 아래와 같이 쓸 수 있음
a += 10;
//산술연산자와 대입 연산자를 같이 쓰는 경우를 통칭함.
```

증감 연산자

```jsx
//숫자형에만 사용 가능
let a = 10;

a++;
console.log(a);
//11이 찍힘
///////////////////////코드 다 지우고 새로 작성//////////////////////////
let a = 10;
console.log(a++);
//이렇게 되면 10이 찍힘 콘솔에 값이 찍히고 a의 값이 증가 됨. (후위 연산)
///////////////////////코드 다 지우고 새로 작성//////////////////////////
let a = 10;
console.log(--a);
//이렇게 하면 9가 찍힘 a의 값이 감소되고 콘솔에 값이 찍힘. (전위 연산)
```

논리 연산자

```jsx
//Boolean 자료형을 위한 연산자

console.log(!true);
//값이 false로 나옴

//AND
console.log( true && true ); 
//true AND true -> 피연산자가 모두 true일 때만 true return

//OR
console.log ( true || false ); 
// true OR false -> 피연산자가 모두 false일 때만 false return

//비교 연산자
let compareA = 1 == '1';
//compareA에 true가 저장됨 , 값만 비교하는 것 , type 비교 x

let compareB = 1 === '1';
//compareB에 false가 저장됨, 값과 type이 모두 비교되는 거라서

let compareC = 1 != '1';
//compareC에 false가 저장됨, 값만 비교해서

let compareD = 1 !== '1';
//compareD에 true가 저장됨, 값과 type 모두 비교해서

let compareE = 1 <= 2;
//compareE에 true가 저장됨 
// < , > , <= , >= 으로 값을 비교할 수 있음

//type of
let a = 1;
a = '1';

console.log(a); // string

//null 병합 연산자
let a; 
a = a ?? 10;
console.log(a); //10 . ??는 null이나 undefined가 아닌 값을 선택함
```

## 조건문

조건문 : 어떤 연산 결과의 참, 거짓 여부에 따라서 다른 명령어를 실행할 수 있도록 하는 것.

```jsx
let a = 5;

if( a >= 7) {
	console.log('7 이상입니다.');
} else if ( a >= 5 ) {
	console.log('5 이상입니다.');
} else {
	console.log('5 미만입니다.');
}
//else if는 여러번 작성할 수 있다. 그러나 else if 를 상당히 많이 써야할 것 같다면 switch 권장

//switch
let country = 'ko';

switch (country) {
	case 'ko':
		console.log('한국');
		break;
	case 'cn':
		console.log('중국');
		break;
	case 'jp':
		console.log('일본');
		break;
	case 'uk':
		console.log('영국');
		break;
	default:
		console.log('미분류');
		break;
}
//break 작성 안 하면 모든 국가가 콘솔에 나오는데 다 코드로 인식하기 때문.

```

## 함수

반복되고 중복되는 코드를 줄이기 위해서 사용.

```jsx
function getArea(width, height){
	let area = width * height;
	console.log(area);
	return area;
} //함수 선언식
//실행하려면 아래와 같이 호출, b에는 20000이 저장됨
b = getArea(100, 200);

//함수 내부에서 선언한 변수나 상수는 함수 밖에서는 접근 할 수 없음 (지역 변수)
//반대로 함수 외부에서 선언한 변수나 상수는 함수 내부에서 접근 가능

```

## 함수표현식 & 화살표 함수

```jsx
console.log(helloB()); 
console.log(helloA()); //error
// 함수 선언식은 호이스팅이 됨. 프로그램 실행 전에 선언식으로 작성된 함수들은 코드 최상단으로 끌어올려진다고 생각하면 됨. 
// 함수 표현식은 호이스팅이 안 됨.

let helloA = function () {
	return '안녕하세요 여러분~';
}; //함수 표현식

const helloText = helloA();
console.log(helloText); 
//안녕하세요 여러분~

function helloB () {
	return '안녕하세요 여러분~';
} //함수 선언식

//함수 표현식을 더 간략하게 사용할 수 있는 방법 = 화살표 함수 
let helloA = () => {
	return 'hello';
} //마찬가지로 호이스팅이 안됨.

```

## 콜백 함수

함수의 파라미터로 함수를 넘겨주는 것

```jsx
function checkMood(mood, goodCallback, badCallback) {
  if (mood === "good") {
    //기분 좋을 때 실행하는 동작
    goodCallback();
  } else {
    //기분 안 좋을 때 실행하는 동작
    badCallback();
  }
}

function cry() {
  console.log("action:cry");
}
function sing() {
  console.log("action:sing");
}
function dance() {
  console.log("action:dance");
}
checkMood("sad", sing, cry);
```

## 객체

```jsx
//객체를 생성하는 2가지 방법
//1. 생성자 사용
let person = new Object();

//2. 객체 리터럴 사용
let person = {
    key: 'value', //객체 프로퍼티
    key1: 'value2',
		name: 'sebin',
		age: 25,
		say: function (){
        console.log(`hello, ${this.name}`);
    }
};
//각각의 프로퍼티는 key와 value로 이루어져있고, value에는 어떤 자료형도 가능하다
//key는 문자열만 가능 (따옴표는 생략) (key가 중복되면 가장 뒤에 있는 값만 사용 가능)

console.log(person.key); //value
console.log(person.name); //sebin
//점을 찍어서 객체의 값에  접근 (점 표기법)

console.log(person['age']); //25
//괄호 안에 key를 넣어서 객체의 값에 접근 (괄호 표기법) 
//반드시 따옴표를 써줘야 함.
//주로 동적인 파라미터를 받는 상황에서 많이 사용함. 

person.location = "한국";
person['gender'] = '여성';
//이렇게 되면 프로퍼티 추가가 됨.

person.age = 24;
//값이 수정됨. 

delete person.key1;
//프로퍼티 삭제 
//메모리는 잡혀있음

person.key1 = null;
//메모리를 날릴 수 있음

person.say();
person['say']()
//메서드 수행

console.log(`name: ${'name' in person}`);
//특정 prop이 객체이 존재하는지 확인
```

## 배열

```jsx
let arr1 = new Array(); //배열 생성자

let arr = []; //배열 리터럴

arr= [1,2,3,4]
//자료형이 달라도 다 넣을 수 있음
//인덱스를 통해서 접근 가능
arr.push(5)
//가장 마지막에 자료 추가

console.log(arr.length);
//배열의 길이
```

## 반복문

특정 명령문을 여러번 반복해야하는 경우

```jsx
for  (let i = 1; i <=100; i++) {
    //반복 수행할 명령
    console.log('sebin');
}

//반복문으로 배열을 순회하는 방법
const arr = [1,2,3,4,5];

for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}

//객체를 순회하는 방법
let person = {
  name: "이정환",
  age: 25,
  tall: 175,
};
const personKeys = Object.keys(person);

for (let i = 0; i < personKeys.length; i++) {
  const curKey = personKeys[i];
  const curValue = person[curKey];

  console.log(`${curKey}: ${curValue}`);
}

const personValues = Object.values(person);

for (let i = 0; i < personValues.length; i++) {
  console.log(personValues[i]);
}

```

## 배열 내장함수

```jsx
const arr = [1,2,3,4,5,6,7];

arr.forEach(function (elm){
    console.log(elm);
});
//배열의 각 요소에 접근

const newArr = arr.map((elm)=>{
    return elm * 2;
});
//각각의 요소에 접근해서 특정 동작을 수행한 후 배열로 반환

let number = 3;

console.log(arr.includes(number));
//배열에 number가 있는지 확인하고 true,false 반환

console.log(arr.indexOf(number));
//전달받은 인자와 일치하면 인덱스 반환하고 없다면 -1 반환

const arr = [
  { color: "red" },
  { color: "black" },
  { color: "blue" },
  { color: "green" },
];
let number = 3;

console.log(
  arr.findIndex((elm) => {
    return elm.color === "green";
  })
);
//3
//그러나 findIndex는 가장 먼저 조건에 일치하는 인덱스를 반환해서 'green'이 두 개인 경우에 문제가 생길 수 있음
 
console.log(arr.filter((elm) => elm.color === "blue"));
//blue에 해당하는 요소를 배열로 반환

console.log(arr.slice(0,2));
//배열을 자름 0번 인덱스(포함)부터 2번 인덱스(미포함)까지

const arr1 = [
  { num: 1, color: "red" },
  { num: 2, color: "black" },
  { num: 3, color: "blue" },
  { num: 4, color: "green" },
  { num: 5, color: "blue" },
];

const arr2 = [
  { num: 6, color: "purple" },
  { num: 7, color: "orange" },
];

//concat
console.log(arr1.concat(arr2));
//arr1에 arr2를 붙인 배열이 반환됨

//join
let chars = ['나','다','가'];

chars.sort(); //원본 배열의 순서를 정렬함. 

let nums = [0,1,6,2,4,10];
nums.sort(); // 0,1,10.2,4,6 -> 문자열 기준으로 정렬(사전순)

const compare = (a,b) =>{
    if(a>b){ //2.크다
        return 1;
    }
    if(a<b){ //3.작다
        return -1;
    }
    return 0; //1.같다
};

nums.sort(compare); //숫자 형태로 sorting됨

//join
const arr = ['이정훈','님','어서오세요']

console.log(arr.join(" ")); //이정훈 님 어서오세요 //join() 이 괄호에 들어가는 값은 구분자
```

# Section 2 - JS 응용

## Truthy & Falsy

참 같은 값, 거짓 같은 값

```jsx
let a = '';

if(a) {
    console.log('true');
} else {
    console.log('false');
}
//false
//a는 빈 문자열이지만 거짓으로 인지됨. -> falsy

//a에 'string'을 넣어주면 참으로 인지됨. -> truthy
```

truthy에 해당하는 값  :  빈 배열, 빈 중괄호, 숫자, 문자열, Infinity,

falsy에 해당하는 값 :  null, undefined, 숫자 0 , Nan, 빈 문자열

```jsx
const getName = (person) => {
  return person.name;
};

let person = { name: "sebin" }; // let person; 으로 수정 시 error 발생 //아래와 같이 수정
const n = getName(person);

console.log(n); //sebin 출력
```

```jsx
const getName = (person) => {
  if (person === undefined) {
    return "객체가 아닙니다.";
  }
  return person.name;
};

let person;                  //let person = null; 으로 수정 시 error 발생 아래와 같이 수정
const n = getName(person);

console.log(n); //객체가 아닙니다
```

```jsx
const getName = (person) => {
  if (!person) {                 //falsy한 값들에 반전 -> 참으로 변경 가능
    return "객체가 아닙니다.";
  }
  return person.name;
};

let person = null;
const n = getName(person);

console.log(n);
```

## 삼항 연산자

```jsx
let a = 3;
a >= 0 ? console.log("양수") : console.log("음수");
// 조건식 ? 참일 때 수행할 코드 : 거짓일 때 수행할 코드

//중첩 수행 시 여러 조건을 검사할 수 있으나 가독성이 떨어지므로 적당한 선에서 사용할 것.

//학점 검사
//~90: a+
//89~80: b+
//79~: c+

let score = 87;

score >= 90
  ? console.log("a+")
  : score >= 80
  ? console.log("b+")
  : console.log("c+");
```

## 단락 회로 평가

왼쪽에서 오른쪽으로 연산하는 논리연산자의 특성을 이용한 기능

```jsx
const getName = (person)=>{
    return person && person.name;
};

let person;
const name = getName(person);
console.log(name); //undefined

//
const getName = (person) => {
  const name  = person && person.name;
  return name || '객체가 아닙니다.';
};

let person = null;
const name = getName(person);
console.log(name); // 객체가 아닙니다

//
const getName = (person) => {
  const name = person && person.name;
  return name || "객체가 아닙니다.";
};

let person = { name: "세빈" };
const name = getName(person);
console.log(name); // 세빈
```

## 비구조화 할당

```jsx
let arr =  ['one','two','three'];

let one = arr[0];
let two = arr[1];
let three = arr[2];

console.log(one,two,three);
//복잡, 비효율적
//아래와 같이 수정

let arr =  ['one','two','three'];

let [one,two,three] = arr;

console.log(one,two,three); //one two three

//이것도 가능
let [one,two,three, four = 'four'] =  ['one','two','three'];

console.log(one,two,three,four); //one two three four

//swap 구현
let a = 10;
let b = 20;
[a,b] = [b,a];
console.log(a,b) // 20 10

//객체의 경우 순서 상관없이 key 값으로 받아온다. 
let object = {one:'one', two:'two', three: 'three',name:'sebin'};

let {name, one, two, three} = object;

console.log(one, two, three, name ) //one two three sebin
//이름 바꿔서 할당받을 수도 있음
let object = {one:'one', two:'two', three: 'three',name:'sebin'};

let {name: myName, one: oneOne, two, three, abc = 'four'} = object;

console.log(oneOne, two, three, myName,abc ) //one two three sebin four
```

## 스프레드 연산자

```jsx
const cookie = {
    base: 'cookie',
    madIn: 'KOREA'
}

const chocochipCookie = {
    base: 'cookie',
    madIn: 'KOREA',
    topping: 'chocochip',
}
const blueberryCookie = {
    base: 'cookie',
    madIn: 'KOREA',
    topping: 'blueberry',
}
const strawberryCookie = {
    base: 'cookie',
    madIn: 'KOREA',
    topping: 'strawberry',
}
//상당히 중복 아래와 같이 수정 가능

const cookie = {
  base: "cookie",
  madIn: "KOREA",
};

const chocochipCookie = {
  ...cookie,
  topping: "chocochip",
};
const blueberryCookie = {
  ...cookie,
  topping: "blueberry",
};
const strawberryCookie = {
  ...cookie,
  topping: "strawberry",
};

//배열에서의 스프레드 연산자
const noToppingCookies = ['촉촉한 쿠키','안촉촉한 쿠키'];
const toppingCookies = ['바나나 쿠키','황치즈쿠키','딸기쿠키','초코칩쿠키'];

const allCookies = [...noToppingCookies,...toppingCookies];
console.log(allCookies); //['촉촉한 쿠키','안촉촉한 쿠키','바나나 쿠키','황치즈쿠키','딸기쿠키','초코칩쿠키']
```

## 동기 & 비동기

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%201.png)

연산 과정을 스레드가 처리하는데 앞의 task가 완료되어야 다음 task를 수행

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%202.png)

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%203.png)

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%204.png)

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%205.png)

하나의 작업이 쓰레드를 점유하지 않는 방식 = 비동기 방식

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%206.png)

비동기 작업이 제대로 완료되었는지 확인하려면 콜백함수를 붙이면 됨

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%207.png)

JS가 동기 /비동기 함수를 구분하는 방법

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%208.png)

JS로 작성한 코드들은 JS엔진에 의해 해석되고 실행 됨. JS 엔진은 힙과 콜 스택으로 이루어져있는데 Call Stack에서 코드가 실행 됨. 

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%209.png)

-자바 스크립트가 동작하는 방식과 관련되어 있음

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2010.png)

*스레드 : 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위

-동기적 처리의 단점:  하나의 작업이 너무 오래 걸리면 그 작업이 종료되기 전까지  모든 작업이 멈추기 때문에 전반적인 흐름이 느려진다. 

⇒ 멀티 스레드로 해결 가능

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2011.png)

**but!! js는 싱글 쓰레드로 동작함**

따라서 비동기 방식으로  해결

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2012.png)

동시에 실행시켜 놓고 작업들이 제대로 수행 되었는지 결과를 확인하기 위해서는 각각의 task 뒤에 콜백 함수를 붙여서 전달

js 엔진의 구성 요소

heap(메모리 할당)  & call stack(코드 실행) 

-동기 코드 실행 원리는 어렵지 않게 이해 가능

-비동기 코드가 작동하는 방식

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2013.png)

-callback queue , event loop, web apis 는 자바 스크립트 엔진과 웹 브라우저의 상호작용(ex: 비동기 처리)을 처리하기 위해 존재 

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2014.png)

코드를 순차적으로 실행한 후에 자바스크립트 엔진은 setTimeout()과 cb()를 web APIs로 넘김

(비동기 함수이기 때문에) 

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2015.png)

asyncAdd()함수의 시행을 마치고 3초의 시간이 흐르면 cb()가 callback Queue로 옮겨짐. 

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2016.png)

event Loop는 Call Stack에 Main Context외의 다른 함수가 있는지 확인한다. 다른 함수가 없다면 event Loop는 cb() 함수를 Call Stack으로 이동시킨다. 

## Promise

-비동기 함수의 결과 값을 활용하기 위해서 callback 함수를 줄지어 사용하는 것을 callback 지옥이라고 함

⇒ 자바스크립트의 비동기를 돕는 객체 promise를 활용하여 해결할 수 있음.

비동기 작업의 3가지 상태

- pending(대기 상태)
- fulfilled(성공)
- rejected(실패)

## async & await

비동기를 다루는 기능 , promise를 더 쉽고 가독성 좋게 작성할 수 있게 해줌. 

함수 이름 앞에 async 키워드를 덧붙이면 그 함수는 promise 객체를 반환함 

```jsx
function hello() { return "hello"; }

async function helloAsync() { return "hello Async"; }

helloAsync.then((res) => { console.log(res); });
///이렇게 하면 hello Async가 콘솔 창에 뜸.
```

await 키워드를 비동기 함수 호출 앞에 붙이면 동기적으로 작동하게 됨. 즉, await이 붙은 함수의 수행이 끝나야 다음 줄의 코드 실행 

⇒ async 키워드가 붙은 함수 내에서만 사용 가능. 

## API 호출하기

API (Application Programming Interface) 응용 프로그램 프로그래밍 인터페이스란?

응용 프로그램에서 사용할 수 있도록, 운영 체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스를 뜻한다. 주로 파일 제어, 창 제어, 화상 처리, 문자 제어 등을 위한 인터페이스를 제공한다. 

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2017.png)

api 호출 = 웹브라우저(client) 를 통해서 server에게 data를 요청하고 전달받는 과정

(= 다른 프로그램에게 data를 받기 위해 말을 거는 것) 

js 함수와의 차이점은 응답을 언제 받을 지 알 수 없다는 것. ⇒ data 요청에 응답하는 시간이 인터넷 속도, 서버의 부하 상태에 따라 달라서 비동기 처리가 필요함. 

```jsx
let response = fetch('api 주소').then((res)=>{
	console.log(res);
};
//이렇게 하면 api 결과 자체를 반환하는 것이 아니라 api 성공 객체 자체를 반환하기 때문에 (=편지랑 편지봉투가 같이 있다)

//이렇게 작성
async function getData() {
	let rawResponse = await fetch('api address');
	let jsonResponse = await rawResponse.json();
	console.log(jsonResponse);
}
getData();
//이렇게 해야 배열 안에 원하는 data가 담겨서 전달 됨. 
```

# Section 3 - Node.js 기초

## Node.js란?

노드.js란? 자바스크립트의 런타임 = 자바스크립트의 실행환경

자바스크립트 코드는 브라우저 내장 자바스크립트 엔진을 이용하여 실행(각각의 브라우저는 다른 자바스크립트 엔진을 실행함.)

자바스크립트의 엔진을 사용해야 하기 때문에  자바스크립트는 웹브라우저에서만 실행되어야 했었음. 그리고 브라우저는 html 문서를 기반으로 동작함.  따라서 자바스크립트는 html 문서 안에서 사용했었음.

개발자들이 좋은 언어를 브라우저가 아닌 환경에서 실행하고 싶어했음

마침 크롬의 자바스크립트 엔진인 v8이 c++로 개발되어서 브라우저가 아니더라도 어디서든 이 엔진을 사용할 수 있었고, 이 엔진을 사용하여 자바스크립트를 브라우저가 아닌 어디에서든 실행시킬 수 있도록 하는 프로젝트를 실행했음. 그 프로젝트의 이름이 node.js

node.js 덕분에 js로 카톡, ppt 등의 pc 프로그램도 만들 수 있게 되었고, web server까지 만들 수 있게 됨. 

 GUI(Graphic User Interface) - 바탕 화면의 아이콘을 더블 클릭해서 프로그램을 실행하는 경우 → 운영체제에 명령을 내리는 것

CLI( Command Line Interface) - 터미널에 명령어를 입력해서 운영체제에 명령을 내리는 것 

node.js 를 통해 가능해진 것

-파일 실행 

ex)node index.js

-모듈을 내보내고 불러오는 것

ex) module.exports = {} 내보내기

ex) const calc = require(’./calc’) 불러오기

둘 다 node.js 의 내장 함수라서 바닐라.js에선 사용 불가

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2018.png)

-패키지 생성 및 외부 패키지 사용

⇒ npm (Node Package Manager) : Node.js의 패키지 관리 도구로 다른 사람들이 만들어 놓은 모듈을 사용할 수 있게 도와주고 우리가 개발할 프로젝트를 관리할 수 있게 도와 줌.

# Section 4 - React.js 기초

## React란?

why React?

React = 자바스크립트의 UI 라이브러리 (Facebook이 개발한 오픈소스)

-컴포넌트로 분리해서 유지, 보수가 용이함

-선언형 프로그래밍이기 때문에 코드가 더 짧고 단순함. 

-Virtual DOM (Document Object Model) : update하거나 render하는 횟수를 줄일 수 있음. 

React.js 는 Node 기반의 Javascript UI 라이브러리

 webpack 은 다수의 자바스크립트 파일을 하나의 파일로 합쳐주는 모듈 번들 라이브러리

Babel 은 JSX 등의 쉽고 직관적인 자바스크립트 문법을 사용할 수 있도록 해주는 라이브러리

# Section 5

목표 1. 사용자 입력 및 배열 리스트 처리하기

목표 2. React Lifecycle 과 API 

목표 3. React App 성능 최적화하기

목표 4. React 컴포넌트 트리에 전역 데이터 공급하기

## React에서 사용자 입력 처리하기 - useState

**구현하고자 하는 것**

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2019.png)

**학습 목표** 

1. 한 줄, 여러 줄 입력 처리하기
2. 선택박스 입력 처리하기
3. 사용자 입력 데이터 핸들링하기

**단계 1 - CRA (Create-React-App)로 디렉토리 생성하고 불필요한 파일 삭제**

터미널에 ‘npx create-react-app {파일명}’ 입력

App.text.js, logo.svg, reportWebVitals.js, setUpTests.js 등의 파일 삭제

태그 구성  일단. 오늘의 일기, input 설정 → 이렇게 했을 때  이벤트가 발생(사용자의 입력) onChange 함수를 따로 설정해주지 않으면 화면에 반영되지 않음 —> onchange 함수 구현 useState로 상태 관리 하는 것까지 포함해서 설명

**단계2 - 태그 구성 (input, textarea, button)**

```jsx
const DiaryEditor = () => {
  return (
    <div className="DiaryEditor">
      <h2>오늘의 일기</h2>
      <div>
        <input name="author"/>
      </div>
      <div>
        <textarea name="content"/>
      </div>
      <div>
        <span>오늘의 감정 점수 : </span>
        <select name="emotion">
          <option value={1}>1</option>
          <option value={2}>2</option>
          <option value={3}>3</option>
          <option value={4}>4</option>
          <option value={5}>5</option>
        </select>
      </div>
      <div>
        <button>일기 저장하기</button>
      </div>
    </div>
  );
};
export default DiaryEditor;
```

태그 구성 후 나타나는 화면

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2020.png)

화면만 구성했기 때문에 아무런 기능도 수행할 수 없다..(당연함.)

태그에 대한 설명을 덧붙이자면, input 태그는 한 줄짜리 입력을 받을 때 사용하고, textarea는 여러 줄의 입력을 받을 때 사용한다. 

span 태그는 div와 유사하지만 inline 속성을 갖는 태그다. 

select 태그는 option 태그의 값을 선택할 수 있도록 해준다. 

button 태그는 말 그대로 버튼을 생성한다. 

이렇게 화면을 구성했으니 사용자의 입력을 처리해주도록 하겠다.

**단계 3 - 사용자의 입력 처리하기** 

위의 태그들은 이벤트(예를 들어 사용자의 입력…)가 발생했을 때 아무런 기능을 수행하지 못하므로 사용자의 입력을 저장해줄 변수와 상태관리 함수를 작성해야 한다. → useState() 사용

```jsx
import { useState } from "react"; /*잊지 않고 import 해줘야 함.*/

const DiaryEditor = () => {
  const [author, setAuthor] = useState(""); /*작성자를 저장하는 변수와 상태관리 함수*/
  const [content, setContent] = useState(""); /*일기 내용을 저장하는 변수 & 상태관리 함수*/
	const [emotion, setEmotion] = useState(1);

  return (
    <div className="DiaryEditor">
      <h2>오늘의 일기</h2>
      <div>
        <input
          name="author"
          value={author}
          onChange={(e) => {
            setAuthor(e.target.value);  
            console.log(author);
          }}
        />
      </div>
      <div>
        <textarea
          name="content"
          value={content}
          onChange={(e) => {
            setContent(e.target.value);
            console.log(content);
          }}
        />
      </div>
      <div>
        <span>오늘의 감정 점수 : </span>
        <select 
						name ="emotion"
						value = {emotion} 
						onChange={(e) => {
							setEmotion(e.target.value);
				}}>
          <option value={1}>1</option>
          <option value={2}>2</option>
          <option value={3}>3</option>
          <option value={4}>4</option>
          <option value={5}>5</option>
        </select>
      </div>
      <div>
        <button>일기 저장하기</button>
      </div>
    </div>
  );
};
export default DiaryEditor;
```

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2021.png)

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2022.png)

이런식으로 input 과 textarea의 값이 변하면 setAuthor(e.target.value), setContent(e.target.value)가 실행되고 console.log가 수행된다. select 태그의 option의 값이 변하면 setEmotion(e.target.value)가 수행된다.

***그런데 state의 자료형이 유사하고 이벤트 처리의 동작이 유사하기 때문에 여러 개의 state를 하나의 state로 묶어줄 수 있다***

```jsx
import { useState } from "react";

const DiaryEditor = () => {
  const [state, setState] = useState({
    author: "",
    content: "",
		emotion: 1,
  });    /*이렇게 하면 3개의 상태를 하나의 변수와 상태관리 함수로 관리할 수 있음*/

  return (
    <div className="DiaryEditor">
      <h2>오늘의 일기</h2>
      <div>
        <input
          name="author"
          value={state.author}
          onChange={(e) => {
            setState({ ...state, author: e.target.value });
            console.log(state.author);
          }}
        />
      </div>
      <div>
        <textarea
          name="content"
          value={state.content}
          onChange={(e) => {
            setState({ ...state, content: e.target.value });
            console.log(state.content);
          }}
        />
      </div>
      <div>
        <span>오늘의 감정 점수 : </span>
        <select 
					name="emotion" 
					value ={state.emotion} 
					onChange={(e)=>{
					setState({...state, emotion: e.target.value});
					}}
				>
          <option value={1}>1</option>
          <option value={2}>2</option>
          <option value={3}>3</option>
          <option value={4}>4</option>
          <option value={5}>5</option>
        </select>
      </div>
      <div>
        <button>일기 저장하기</button>
      </div>
    </div>
  );
};
export default DiaryEditor;
```

스프레드 연산자: 원래 객체가 가지고 있는 property를 그대로 옮기는 것.

순서에 유의해야 값이 제대로 전달될 수 있다. 

***그리고 이벤트가 발생한 태그의 이름과 상태를 동일하게 설정했고, 상태 변화가 일어났을 때 수행하는 함수가 유사하기 때문에 다음과 같이 코드를 수정할 수 있다.***

```jsx
import { useState } from "react";

const DiaryEditor = () => {
  const [state, setState] = useState({
    author: "",
    content: "",
    emotion: 1,
  });

  const handleChangeState = (e) => {
    setState({ ...state, [e.target.name]: e.target.value });
  };

  return (
    <div className="DiaryEditor">
      <h2>오늘의 일기</h2>
      <div>
        <input
          name="author"
          value={state.author}
          onChange={handleChangeState}
        />
      </div>
      <div>
        <textarea
          name="content"
          value={state.content}
          onChange={handleChangeState}
        />
      </div>
      <div>
        <span>오늘의 감정 점수 : </span>
        <select
          name="emotion"
          value={state.emotion}
          onChange={handleChangeState}
        >
          <option value={1}>1</option>
          <option value={2}>2</option>
          <option value={3}>3</option>
          <option value={4}>4</option>
          <option value={5}>5</option>
        </select>
      </div>
      <div>
        <button>일기 저장하기</button>
      </div>
    </div>
  );
};
export default DiaryEditor;
```

이제 버튼을 눌렀을 때 기능을 설정하도록 하겠다. 

```jsx
import { useState } from "react";

const DiaryEditor = () => {
  const [state, setState] = useState({
    author: "",
    content: "",
    emotion: 1,
  });

  const handleChangeState = (e) => {
    setState({ ...state, [e.target.name]: e.target.value });
  };

  const handleSubmit = () => {
    console.log(state);
    alert("저장 완료");
  };

  return (
    <div className="DiaryEditor">
      <h2>오늘의 일기</h2>
      <div>
        <input
          name="author"
          value={state.author}
          onChange={handleChangeState}
        />
      </div>
      <div>
        <textarea
          name="content"
          value={state.content}
          onChange={handleChangeState}
        />
      </div>
      <div>
        <span>오늘의 감정 점수 : </span>
        <select
          name="emotion"
          value={state.emotion}
          onChange={handleChangeState}
        >
          <option value={1}>1</option>
          <option value={2}>2</option>
          <option value={3}>3</option>
          <option value={4}>4</option>
          <option value={5}>5</option>
        </select>
      </div>
      <div>
        <button onClick={handleSubmit}>일기 저장하기</button>
      </div>
    </div>
  );
};
export default DiaryEditor;
```

버튼이 클릭되면 handleSubmit 함수가 실행되고, 아래 사진처럼 콘솔 창에 state가 뜨고 ‘저장 완료’라는 경고창이 뜬다.

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2023.png)

기능은 다 넣어줬으니 이제 css 차례…(아주 기본적인..)

**단계4 - css 적용**

```jsx
/* DiaryEditor */
.DiaryEditor {
  border: 1px solid gray;
  text-align: center;
  padding:20px;
}

.DiaryEditor input, textarea{
  margin-bottom: 20px;
  width: 500px;
  padding: 10px;
}

.DiaryEditor textarea {
  height: 150px;
}

.DiaryEditor select {
  width: 300px;
  padding: 10px;
  margin-bottom: 20px;
}

.DiaryEditor button {
  width: 500px;
  padding:10px;
  cursor: pointer;
}
```

css 파일까지 작성했다면 꼭 App.js에 import 해주기…^^ 이거 안 하고 왜 적용 안 되냐고 10분 동안 승질 냄…ㅎ

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2024.png)

이렇게 화면이 완성되었습니다~

## React에서 DOM 조작하기

**구현하고자 하는 것**

일기 저장 버튼을 클릭했을 때 작성자와 일기의 내용이 정상적으로 작성되었는지 확인하고 아니라면 focus하기

**학습 목표**

useRef() 

위에서 말했듯이 일기 저장 버튼을 클릭했을 때의 상황을 처리해야 하는 것이기 때문에 handleSubmit의 수정이 필요함.

**단계 1 - useRef import 해주기**

**단계2 - focus 할 DOM 요소(태그) 확인 및 적절한 효과 주기**

→ author의 길이가 1보다 작으면 input에다가 focus 주기

→ content의 길이가 5보다 작으면 textarea에다가 focus 주기

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2025.png)

React.MutableRefObject는 html DOM요소에 접근할 수 있게 해준다.

```jsx
import { useRef, useState } from "react";

const DiaryEditor = () => {
  const authorInput = useRef();
  const contentInput = useRef();

  const [state, setState] = useState({
    author: "",
    content: "",
    emotion: 1,
  });

  const handleChangeState = (e) => {
    setState({ ...state, [e.target.name]: e.target.value });
  };

  const handleSubmit = () => {
    if (state.author.length < 1) {
      authorInput.current.focus();
      return;
    }
    if (state.content < 5) {
      contentInput.current.focus();
      return;
    }
    alert("저장 완료");
  };

  return (
    <div className="DiaryEditor">
      <h2>오늘의 일기</h2>
      <div>
        <input
          ref={authorInput}
          name="author"
          value={state.author}
          onChange={handleChangeState}
        />
      </div>
      <div>
        <textarea
          ref={contentInput}
          name="content"
          value={state.content}
          onChange={handleChangeState}
        />
      </div>
      <div>
        <span>오늘의 감정 점수 : </span>
        <select
          name="emotion"
          value={state.emotion}
          onChange={handleChangeState}
        >
          <option value={1}>1</option>
          <option value={2}>2</option>
          <option value={3}>3</option>
          <option value={4}>4</option>
          <option value={5}>5</option>
        </select>
      </div>
      <div>
        <button onClick={handleSubmit}>일기 저장하기</button>
      </div>
    </div>
  );
};
export default DiaryEditor;
```

## React에서 리스트 렌더링하기

**구현하고자 하는 것**

배열을 이용하여 React에서 LIST를 렌더링해보고 개별적인 컴포넌트로 만들어보기

**학습 목표** 

map() 학습하기

**단계1 - 컴포넌트 생성**

```jsx
const DiaryList = () => {
  return (
    <div className="DiaryList">
      <h2>일기 리스트</h2>
  );
};

export default DiaryList;
```

App.js에도 import해주기

```jsx
import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

import "./App.css";

const App = () => {
  return (
    <div>
      <DiaryEditor />
      <DiaryList/>
    </div>
  );
};
export default App;
```

**단계2 - 임시 배열 생성해서 렌더링**

```jsx
import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";
import "./App.css";

const dummyList = [
  {
    id: 1,
    author: "박세빈",
    content: "오늘의 일기1",
    emotion: 5,
    created_date: new Date().getTime(),
  },
  {
    id: 2,
    author: "박세빈",
    content: "오늘의 일기2",
    emotion: 4,
    created_date: new Date().getTime(),
  },
  {
    id: 3,
    author: "박세빈",
    content: "오늘의 일기3",
    emotion: 3,
    created_date: new Date().getTime(),
  },
];

const App = () => {
  return (
    <div>
      <DiaryEditor />
      <DiaryList diaryList={dummyList} />
    </div>
  );
};
export default App;
```

dummyList를 DiaryList에 diaryList라는 이름의 prop으로 제공

```jsx
const DiaryList = ({ diaryList }) => {
  return (
    <div className="DiaryList">
      <h2>일기 리스트</h2>
      <h4>{diaryList.length}개의 일기가 있습니다.</h4>
      <div>
        {diaryList.map((it) => (
          <div id={it.id}>
            <div>작성자: {it.author}</div>
            <div>일기: {it.content}</div>
            <div>작성된 날짜: {it.created_date}</div>
          </div>
        ))}
      </div>
    </div>
  );
};

DiaryList.defaultProps = [];
export default DiaryList;
```

배열의 형태를 띄고 있기 때문에 각각의 요소에 접근해서 태그 덩어리로 return

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2026.png)

이런 error가 뜨면 맵핑할 때 div 태그에 고유한 id를 부여해주면 된다.

그리고 혹시나 prop이 제대로 전달되지 않았을 때의 경우에 에러가 뜨는 것을 대비해서 DiaryList의 DefaultPorps를 빈 배열로 전달해준다.

*그러나, 이렇게 되면 나중에 수정하기, 삭제하기 기능을 구현할 때 전부 DiaryEditor.js에서 코드를 작성해야 한다.* 

⇒ 바람직하지 않음

**단계 3 - 별도의 컴포넌트 생성**

```jsx
const DiaryItem = ({ id, author, content, emotion, created_date }) => {
  return (
    <div className="DiaryItem">
      <div className="Info">
        <span>
          작성자 : {author} | 감정 점수 : {emotion} |
        </span>
        <br />
        <div className="Date">
          작성된 날짜 : {new Date(created_date).toLocaleString()}
        </div>
      </div>
      <div className="Content">일기 내용 : {content}</div>
    </div>
  );
};
export default DiaryItem;
```

DiaryList.js에 import해주고, 마크업 진행

DiaryList.js는 다음과 같이 수정

```jsx
import DiaryItem from "./DiaryItem";

const DiaryList = ({ diaryList }) => {
  return (
    <div className="DiaryList">
      <h2>일기 리스트</h2>
      <h4>{diaryList.length}개의 일기가 있습니다.</h4>
      <div>
        {diaryList.map((it) => (
          <DiaryItem key={it.id} {...it} />
        ))}
      </div>
    </div>
  );
};

DiaryList.defaultProps = [];
export default DiaryList;
```

단계4 - css 적용

```jsx
/* DiaryItem */

.DiaryItem {
  background-color: rgb(240,240,240);
  margin-bottom: 10px;
  padding: 20px;
}

.DiaryItem .Info {
  border-bottom: 1px solid gray;
  padding-bottom: 10px;
  margin-bottom: 10px;
}

.DiaryItem .Date {
  color: gray;
}

.DiaryItem .Content{
  font-weight: bold;
  margin-bottom: 30px;
  margin-top: 30px;
}
```

## React에서 리스트 데이터 추가하기

**구현하고자 하는 것**

리스트 데이터 추가하기

**학습목표**

데이터의 흐름 이해하고 적절한 기능을 구현한다.

**단계 1 - 코드를 작성하기에 앞서 component tree 구조에 대해서 생각해보기** 

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2027.png)

React에서는 data는 단방향으로 (위에서 아래로) 흐른다. 

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2028.png)

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2029.png)

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2030.png)

따라서 DiaryEditor에는 setDate를 prop으로 전달해야하고,  DiaryList에는 data를 prop으로 전달해야 한다. 

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2031.png)

데이터는 위에서 아래로 흐르지만, event는 아래에서 위로 흐른다. 

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2032.png)

**단계2 - 상태 변수를 설정하고 각각의 컴포넌트에 적절한 prop 넘겨주기**

1>App.js에 일기를 저장하는 data 변수와 상태 관리 함수 import 해주기

2>저장한 일기 data를 DiaryList에 prop으로 전달

3>일기를 생성해서 저장하는 함수 onCreate()을 작성하고 DiaryEditor에 prop으로 전달 

```jsx
import { useState, useRef } from "react";
import "./App.css";

import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

const App = () => {
  const [data, setData] = useState([]);

  const dataId = useRef(0);

  const onCreate = (author, content, emotion) => {
    const created_date = new Date().getTime();
    const newItem = {
      author,
      content,
      emotion,
      created_date: created_date,
      id: dataId.current,
    };
    dataId.current += 1;
    setData([newItem, ...data]);
  };
  return (
    <div>
      <DiaryEditor onCreate={onCreate} />
      <DiaryList diaryList={data} />
    </div>
  );
};
export default App;
```

일기마다 다른 id가 필요하고 새로운 일기가 생성될 때 전 일기의 id를 가져와서 +1 해줘야 한다

⇒ useRef() 사용

```jsx
import { useRef, useState } from "react";

const DiaryEditor = ({ onCreate }) => {
  const authorInput = useRef();
  const contentInput = useRef();

  const [state, setState] = useState({
    author: "",
    content: "",
    emotion: 1,
  });

  const handleChangeState = (e) => {
    setState({ ...state, [e.target.name]: e.target.value });
  };

  const handleSubmit = () => {
    if (state.author.length < 1) {
      authorInput.current.focus();
      return;
    }
    if (state.content < 5) {
      contentInput.current.focus();
      return;
    }
    onCreate(state.author, state.content, state.emotion);
    alert("저장 완료");
    setState({ author: "", content: "", emotion: 1 });
  };

  return (
    <div className="DiaryEditor">
      <h2>오늘의 일기</h2>
      <div>
        <input
          ref={authorInput}
          name="author"
          value={state.author}
          onChange={handleChangeState}
        />
      </div>
      <div>
        <textarea
          ref={contentInput}
          name="content"
          value={state.content}
          onChange={handleChangeState}
        />
      </div>
      <div>
        <span>오늘의 감정 점수 : </span>
        <select
          name="emotion"
          value={state.emotion}
          onChange={handleChangeState}
        >
          <option value={1}>1</option>
          <option value={2}>2</option>
          <option value={3}>3</option>
          <option value={4}>4</option>
          <option value={5}>5</option>
        </select>
      </div>
      <div>
        <button onClick={handleSubmit}>일기 저장하기</button>
      </div>
    </div>
  );
};
export default DiaryEditor;
```

작성 완료 버튼을 눌렀을 때 handleSubmit 함수가 실행되고 이때 onCreate()함수가 실행된다.

state.author, state.content, state.emotion 의 값이 onCreate함수의 로직에 의해 일기 객체로 형성되어 App.js에 저장되고 렌더링된다. 이 후에 input 태그와 textarea 태그의 값은 다시 빈 칸이 되어야 하니까 setState()에 빈 객체를 전달한다. 

## React에서 리스트 데이터 삭제하기

**구현하고자 하는 것**

리스트 데이터 삭제하기

**학습 목표**

filter()

단계1 - 일단 컴포넌트에 삭제 button 생성

```jsx
const DiaryItem = ({
  id,
  author,
  content,
  emotion,
  created_date,
}) => {
  return (
    <div className="DiaryItem">
      <div className="Info">
        <span>
          작성자 : {author} | 감정 점수 : {emotion} |
        </span>
        <br />
        <div className="Date">
          작성된 날짜 : {new Date(created_date).toLocaleString()}
        </div>
      </div>
      <div className="Content">일기 내용 : {content}</div>
      <button>삭제하기</button>
    </div>
  );
};
export default DiaryItem;
```

단계2 - 삭제 버튼 눌렀을 때 적절한 기능을 하는 함수 작성 & 함수를 적절한 컴포너트의 prop으로 전달하기

```jsx
import { useState, useRef } from "react";
import "./App.css";

import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

const App = () => {
  const [data, setData] = useState([]);

  const dataId = useRef(0);

  const onCreate = (author, content, emotion) => {
    const created_date = new Date().getTime();
    const newItem = {
      author,
      content,
      emotion,
      created_date: created_date,
      id: dataId.current,
    };
    dataId.current += 1;
    setData([newItem, ...data]);
  };

  const onRemove = (targetId) => {
    console.log(targetId);
    const newDiaryList = data.filter((it) => it.id !== targetId);
    setData(newDiaryList);
  };

  return (
    <div>
      <DiaryEditor onCreate={onCreate} />
      <DiaryList diaryList={data} onRemove={onRemove} />
    </div>
  );
};
export default App;
```

DiaryList에 onDelete함수를 prop으로 넘겨줘야 DiaryItem에 prop을 넘겨줄 수 있음.

```jsx
import DiaryItem from "./DiaryItem";

const DiaryList = ({ diaryList, onRemove}) => {
  return (
    <div className="DiaryList">
      <h2>일기 리스트</h2>
      <h4>{diaryList.length}개의 일기가 있습니다.</h4>
      <div>
        {diaryList.map((it) => (
          <DiaryItem key={it.id} {...it} onRemove={onRemove} />
        ))}
      </div>
    </div>
  );
};

DiaryList.defaultProps = [];
export default DiaryList;
```

```jsx
const DiaryItem = ({
  id,
  author,
  content,
  emotion,
  created_date,
  onRemove,
}) => {
  return (
    <div className="DiaryItem">
      <div className="Info">
        <span>
          작성자 : {author} | 감정 점수 : {emotion} |
        </span>
        <br />
        <div className="Date">
          작성된 날짜 : {new Date(created_date).toLocaleString()}
        </div>
      </div>
      <div className="Content">일기 내용 : {content}</div>
      <button
        onClick={() => {
          if (window.confirm(`${id}번째 일기를 삭제하시겠습니까?`)) {
            onRemove(id);
          }
        }}
      >
        삭제하기
      </button>
    </div>
  );
};
export default DiaryItem;
```

## React에서 리스트 데이터 수정하기

**구현하고자 하는 것**

리스트 아이템을 동적으로 수정해보기 

**학습 목표**

조건부 렌더링

**단계1 - 수정하기 button 생성**

```jsx
const DiaryItem = ({
  id,
  author,
  content,
  emotion,
  created_date,
  onRemove,
}) => {
  const handleRemove = () => {
    if (window.confirm(`${id}번째 일기를 삭제하시겠습니까?`)) {
      onRemove(id);
    }
  };
  return (
    <div className="DiaryItem">
      <div className="Info">
        <span>
          작성자 : {author} | 감정 점수 : {emotion} |
        </span>
        <br />
        <div className="Date">
          작성된 날짜 : {new Date(created_date).toLocaleString()}
        </div>
      </div>
      <div className="Content">일기 내용 : {content}</div>
      <button onClick={handleRemove}>삭제하기</button>
      <button>수정하기</button>
    </div>
  );
};
export default DiaryItem;
```

**단계2 - button이 클릭되었을 때 구현되어야 하는 기능 작성하기**

1>수정 중인지 아닌지 저장하는 상태 변수와 상태 관리 함수 

2>수정 중일 때 태그에 변화주기

```jsx
import { useState} from "react";

const DiaryItem = ({
  id,
  author,
  content,
  emotion,
  created_date,
  onRemove,
}) => {
  const [isEdit, setIsEdit] = useState(false);

  const handleRemove = () => {
    if (window.confirm(`${id}번째 일기를 삭제하시겠습니까?`)) {
      onRemove(id);
    }
  };

  const toggleIsEdit = () => {
    setIsEdit(!isEdit);
  };

  return (
    <div className="DiaryItem">
      <div className="Info">
        <span>
          작성자 : {author} | 감정 점수 : {emotion} |
        </span>
        <br />
        <div className="Date">
          작성된 날짜 : {new Date(created_date).toLocaleString()}
        </div>
      </div>
      <div className="Content">
        {isEdit ? (<textarea/>) : (content)}
      </div>
      <div>
        {isEdit ? (
          <>
            <button>수정 취소</button>
            <button>수정 완료</button>
          </>
        ) : (
          <>
            <button onClick={handleRemove}>삭제하기</button>
            <button onClick={toggleIsEdit}>수정하기</button>
          </>
        )}
      </div>
    </div>
  );
};
export default DiaryItem;
```

**단계3 - 수정 중일 때 바뀐 버튼이 클릭 되었을 때 작동해야 하는 기능 구현하기**

```jsx
import { useState, useRef } from "react";

const DiaryItem = ({
  id,
  author,
  content,
  emotion,
  created_date,
  onRemove,
  onEdit,
}) => {
  const localContentInput = useRef();

  const [isEdit, setIsEdit] = useState(false);
  const [localContent, setLocalContent] = useState(content);

  const handleRemove = () => {
    if (window.confirm(`${id}번째 일기를 삭제하시겠습니까?`)) {
      onRemove(id);
    }
  };

  const toggleIsEdit = () => {
    setIsEdit(!isEdit);
  };

  const HandleQuitEdit = () => {
    setIsEdit(false);
    setLocalContent(content);
  };

  const handleEdit = () => {
    if (localContent.length < 5) {
      localContentInput.current.focus();
      return;
    }
    if (window.confirm(`${id}번째 일기를 수정하시겠습니까?`)) {
      onEdit(id, localContent);
      toggleIsEdit();
    }
  };

  return (
    <div className="DiaryItem">
      <div className="Info">
        <span>
          작성자 : {author} | 감정 점수 : {emotion} |
        </span>
        <br />
        <div className="Date">
          작성된 날짜 : {new Date(created_date).toLocaleString()}
        </div>
      </div>
      <div className="Content">
        {isEdit ? (
          <textarea
            ref={localContentInput}
            value={localContent}
            onChange={(e) => {
              setLocalContent(e.target.value);
            }}
          />
        ) : (
          content
        )}
      </div>
      <div>
        {isEdit ? (
          <>
            <button onClick={HandleQuitEdit}>수정 취소</button>
            <button onClick={handleEdit}>수정 완료</button>
          </>
        ) : (
          <>
            <button onClick={handleRemove}>삭제하기</button>
            <button isEdit={isEdit} onClick={toggleIsEdit}>
              수정하기
            </button>
          </>
        )}
      </div>
    </div>
  );
};
export default DiaryItem;
```

수정하기 버튼이 눌렸을 때, 기존의 일기 내용을 불러와야 하고, 수정된 일기 내용을 렌더링 해줘야 하기 때문에 별도의 상태를 설정해줘야 한다. 

해당 일기를 수정하다가 도중에 그만두는 경우와 수정 완료 버튼을 눌렀을 때의 경우에 대해 각각 handleQuitEdit 과 handleEdit을 구현한다.

handleEdit을 구현할 때, 일기 내용이 5글자 미만인 경우에는 해당 DOM요소에 focus를 주기 위해 useRef를 import해주고, 5글자 이상일 때는 윈도우 창을 띄우고 onEdit을 실행한다. onEdit은 App.js에 있으므로 prop으로 전달 받아야 한다. 

```jsx
import { useState, useRef } from "react";
import "./App.css";

import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

const App = () => {
  const [data, setData] = useState([]);

  const dataId = useRef(0);

  const onCreate = (author, content, emotion) => {
    const created_date = new Date().getTime();
    const newItem = {
      author,
      content,
      emotion,
      created_date: created_date,
      id: dataId.current,
    };
    dataId.current += 1;
    setData([newItem, ...data]);
  };

  const onEdit = (targetId, newContent) => {
    setData(
      data.map((it) =>
        it.id === targetId ? { ...it, content: newContent } : it
      )
    );
  };

  const onRemove = (targetId) => {
    console.log(targetId);
    const newDiaryList = data.filter((it) => it.id !== targetId);
    setData(newDiaryList);
  };

  return (
    <div>
      <DiaryEditor onCreate={onCreate} />
      <DiaryList diaryList={data} onRemove={onRemove} onEdit={onEdit} />
    </div>
  );
};
export default App;
```

onEdit이라는 prop은 DiaryList를 거쳐서 DiaryItem으로 전달되기 때문에 DiaryList.js도 수정한다.

```jsx
import DiaryItem from "./DiaryItem";

const DiaryList = ({ diaryList, onRemove, onEdit }) => {
  return (
    <div className="DiaryList">
      <h2>일기 리스트</h2>
      <h4>{diaryList.length}개의 일기가 있습니다.</h4>
      <div>
        {diaryList.map((it) => (
          <DiaryItem key={it.id} {...it} onRemove={onRemove} onEdit={onEdit} />
        ))}
      </div>
    </div>
  );
};

DiaryList.defaultProps = [];
export default DiaryList;
```

## React Lifecycle 제어하기

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2033.png)

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2034.png)

컴포넌트가 탄생하고 변화하고 사라지는 순간에 어떤 작업을 수행 하는 것을 라이프 사이클을 제어한다고 한다. 

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2035.png)

컴포넌트가 탄생할 때 수행되는 메서드 = ComponentDidMount

컴포넌트가 업데이트 될 때 수행되는 메서드 = ComponentDidUpdate

컴포넌트가 화면에서 사라질 때 수행되는 메서드 = ComponentWillUnmount

그러나, 이런 메서드는 클래스형 컴포넌트에서만 사용 가능

엄밀하게는 상태 관리도 클래스형 컴포넌트에서만 사용 가능 

→hook을 사용하므로써 클래스형 컴포넌트에서만 사용 가능했던 메서드를 함수형 컴포넌트에서도 사용할 수 있게 됨. ex) useState, useEffect, useRef

(클래스형 컴포넌트는 함수형 컴포넌트에 비해 코드 길이가 길고, 중복되는 코드가 많으며 가독성이 떨어진다.)

```jsx
import { useState, useEffect } from "react";

const Lifecycle = () => {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  useEffect(() => {
    console.log("Mount!");
  }, []);

  useEffect(() => {
    console.log("Update!");
  });

  return (
    <div style={{ padding: 20 }}>
      <div>
        {count}
        <button onClick={() => setCount(count + 1)}>+</button>
      </div>
      <div>
        <input
          value={text}
          onChange={(e) => {
            setText(e.target.value);
          }}
        />
      </div>
    </div>
  );
};

export default Lifecycle;
```

콘솔에는 컴포넌트가 mount될 때에만 ‘Mount!’라고 찍힘 ⇒ 의존성 배열이 빈배열이라서

반면 count나 text가 변할 때마다 ‘Update!’가 찍힘 ⇒ 의존성 배열을 넣지 않아서

```jsx
import { useState, useEffect } from "react";

const Lifecycle = () => {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  useEffect(() => {
    console.log("Mount!");
  }, []);

  useEffect(() => {
    console.log("Update!");
  });

  useEffect(() => {
    console.log(`count is updated: ${count}`);
    if (count > 5) {
      alert("count가 5를 넘었습니다. 따라서 1로 초기화합니다.");
      setCount(1);
    }
  }, [count]);

  useEffect(() => {
    console.log(`text is updated: ${text}`);
  }, [text]);

  return (
    <div style={{ padding: 20 }}>
      <div>
        {count}
        <button onClick={() => setCount(count + 1)}>+</button>
      </div>
      <div>
        <input
          value={text}
          onChange={(e) => {
            setText(e.target.value);
          }}
        />
      </div>
    </div>
  );
};

export default Lifecycle;
```

이렇게 작성한 경우, text가 변할 때에는 콘솔에 text is updated: ${text}가 찍히고, count가 변할 때에는 count is updated: ${count}가 찍힌다. count의 값이 5를 초과한 경우에는 1로 설정되기도 한다. ⇒ 의존성 배열에 각각 count 와 text가 담겨서 해당 값이 변할 때마다 callback 함수가 실행되는 것

다음 코드는 함수가 unmount될 때 useEffect의 동작을 살펴보는 코드다

```jsx
import { useState, useEffect } from "react";

const UnmountTest = () => {
  useEffect(() => {
    console.log("Mount!");

    return () => {
      console.log("Unmount!");
    };
  }, []);

  return <div>Testing Unmounting Componenet</div>;
};

const Lifecycle = () => {
  const [isVisible, setIsVisible] = useState(false);
  const toggleVisible = () => setIsVisible(!isVisible);

  return (
    <div style={{ padding: 20 }}>
      <button onClick={toggleVisible}>on/off</button>
      {isVisible && <UnmountTest />}
    </div>
  );
};

export default Lifecycle;
```

컴포넌트가 Mount 될 때에는  console.log("Mount!"); 코드가 실행되어서 콘솔에 Mount!가 찍히고, 컴포넌트가 Unmount될 때에는 console.log("Unmount!"); 코드가 실행되어서 콘솔에 Unmount!가 찍힌다.

⇒ 컴포넌트가 Unmount될 때 특정 기능을 수행하도록 하고 싶다면 useEffect의 call back 함수의 return 에 특정기능을 구현하면 된다.

## React에서 API 호출하기

**구현하고자 하는 것** 

일기 내용에 api에서 호출한 것 담아주기

**학습 목표** 

useEffect , fetch를 이용하여 컴포넌트 Mount 시점에 API를 호출하고 해당 API의 결과값을 일기 데이터의 초기값으로 이용하기

먼저, 무료로 API 서비스를 제공하는 jsonplaceholder 이용

[https://jsonplaceholder.typicode.com/comments](https://jsonplaceholder.typicode.com/comments) 에서 comments resource 이용

api를 호출하는 함수 구현 - js api 내장 객체인 fetch 이용

async await 사용

getData 는 promise를 반환하는 비동기 함수

```
import { useState, useRef, useEffect } from "react";
import "./App.css";

import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

// https://jsonplaceholder.typicode.com/comments

const App = () => {
  const [data, setData] = useState([]);

  const dataId = useRef(0);

  const getData = async () => {
    const res = await fetch(
      "https://jsonplaceholder.typicode.com/comments"
    ).then((res) => res.json());
    console.log(res);
  };

  useEffect(() => {
    getData();
  }, []);

  const onCreate = (author, content, emotion) => {
    const created_date = new Date().getTime();
    const newItem = {
      author,
      content,
      emotion,
      created_date: created_date,
      id: dataId.current,
    };
    dataId.current += 1;
    setData([newItem, ...data]);
  };

  const onEdit = (targetId, newContent) => {
    setData(
      data.map((it) =>
        it.id === targetId ? { ...it, content: newContent } : it
      )
    );
  };

  const onRemove = (targetId) => {
    console.log(targetId);
    const newDiaryList = data.filter((it) => it.id !== targetId);
    setData(newDiaryList);
  };

  return (
    <div>
      <DiaryEditor onCreate={onCreate} />
      <DiaryList diaryList={data} onRemove={onRemove} onEdit={onEdit} />
    </div>
  );
};
export default App;
```

이렇게 되면 마운트되는 시점에 api가 호출되어서 콘솔에 json data가 찍힘. 

이제 이 데이터를 일기 데이터의  기초 data로 사용할 것

body는 일기 데이터의 본문, email은 작성자로 사용

단, 20개의 데이터만 추려서 사용할 것이기 때문에 slice() 해준다.

```jsx
import { useState, useRef, useEffect } from "react";
import "./App.css";

import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

// https://jsonplaceholder.typicode.com/comments

const App = () => {
  const [data, setData] = useState([]);

  const dataId = useRef(0);

  const getData = async () => {
    const res = await fetch(
      "https://jsonplaceholder.typicode.com/comments"
    ).then((res) => res.json());
    console.log(res);
    const initData = res.slice(0, 20).map((it) => {
      return {
        author: it.email,
        content: it.body,
        emotion: Math.floor(Math.random() * 5) + 1,
        created_date: new Date().getTime(),
        id: dataId.current++,
      };
    });
    setData(initData);
  };

  useEffect(() => {
    getData();
  }, []);

  const onCreate = (author, content, emotion) => {
    const created_date = new Date().getTime();
    const newItem = {
      author,
      content,
      emotion,
      created_date: created_date,
      id: dataId.current,
    };
    dataId.current += 1;
    setData([newItem, ...data]);
  };

  const onEdit = (targetId, newContent) => {
    setData(
      data.map((it) =>
        it.id === targetId ? { ...it, content: newContent } : it
      )
    );
  };

  const onRemove = (targetId) => {
    console.log(targetId);
    const newDiaryList = data.filter((it) => it.id !== targetId);
    setData(newDiaryList);
  };

  return (
    <div>
      <DiaryEditor onCreate={onCreate} />
      <DiaryList diaryList={data} onRemove={onRemove} onEdit={onEdit} />
    </div>
  );
};
export default App;
```

이렇게 되면 

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2036.png)

화면에 일기 데이터 20개가 나타난다

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%80%E1%85%B5%20be6a156c153f48049f84c633fc175ed7/Untitled%2037.png)