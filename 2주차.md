# 2주차

## React Developer Tools

개발을 도와주는 크롬의 extension 

설치 절차

1) 크롬에 웹 스토어 검색

2) 크롬 웹 스토어에서 react developer tools 검색

3) 최상단에 뜨는 것 클릭 후 크롬에 설치 (제공자가 facebook)

4) 크롬의 오른쪽 상단 점 세개 (옵션) 클릭 > 도구 더보기 > 확장프로그램 

5) react developer tools의 switch on

6) react developer tools의 세부정보 페이지에 접속 후 ‘사이트 액세스’ > 모든 사이트에서 

‘파일 url에 대한 액세스 허용’> switch on 

시크릿 모드에서 개발하는 경우 ‘시크릿 모드에서 허용’ >switch on

⇒ 리액트 앱을 실행하고 개발자 도구에서 react developer tools의 기능 확인

- component의 tab을 클릭하면 우리가 만든 컴포넌트의 계층구조를 해석해서 보여줌
- 어떤 props를 받았는지, 리스트 아이템의 키 값, state, 사용하고 있는 hook 등을 보여줌

## 최적화1 - useMemo

**구현하고자 하는 것** 

현재 일기 데이터를 분석하는 함수를 제작하고 해당 함수가 일기 데이터의 길이가 변화하지 않을 때 값을 다시 계산하지 않도록 하기

**학습목표**

Memoization 이해하기 

**Memoization이란?** 

이미 연산 한 것의 결과를 기억해두었다가 동일한 계산을 시키면 다시 연산하지 않고 기억해두었던 데이터를 반환 하게 하는 방법 

= 시험 볼 때, 이미 푼 문제는 다시 풀지 않고 답을 아는 것과 유사

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20(React%20js)%20be6a156c153f48049f84c633fc175ed7/Untitled.png)

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20(React%20js)%20be6a156c153f48049f84c633fc175ed7/Untitled%201.png)

단계1>data state가 가진 일기 중에서 기분 좋은 일기의 개수, 기분이 나쁜 일기의 개수, 기분이 좋은 일기의 비율을 구하는 함수 작성

```jsx
import { useState, useRef, useEffect } from "react";
import "./App.css";

import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

const App = () => {
  const [data, setData] = useState([]);

  const dataId = useRef(0);

  const getData = async () => {
    const res = await fetch(
      "https://jsonplaceholder.typicode.com/comments"
    ).then((res) => res.json());
    console.log(res);
    const initData = res.slice(0, 20).map((it) => {
      return {
        author: it.email,
        content: it.body,
        emotion: Math.floor(Math.random() * 5) + 1,
        created_date: new Date().getTime(),
        id: dataId.current++,
      };
    });
    setData(initData);
  };

  useEffect(() => {
    getData();
  }, []);

  const onCreate = (author, content, emotion) => {
    const created_date = new Date().getTime();
    const newItem = {
      author,
      content,
      emotion,
      created_date: created_date,
      id: dataId.current,
    };
    dataId.current += 1;
    setData([newItem, ...data]);
  };

  const onEdit = (targetId, newContent) => {
    setData(
      data.map((it) =>
        it.id === targetId ? { ...it, content: newContent } : it
      )
    );
  };

  const onRemove = (targetId) => {
    console.log(targetId);
    const newDiaryList = data.filter((it) => it.id !== targetId);
    setData(newDiaryList);
  };

  const getDiaryAnalysis = () => {
    console.log("일기 분석 시작");

    const goodCount = data.filter((it) => it.emotion >= 3).length;
    const badCount = data.length - goodCount;
    const goodRatio = (goodCount / data.length) * 100;
    return { goodCount, badCount, goodRatio };
  };

  const { goodCount, badCount, goodRatio } = getDiaryAnalysis();
  return (
    <div>
      <DiaryEditor onCreate={onCreate} />
      <div>전체 일기 : {data.length} </div>
      <div>기분 좋은 일기 개수 : {goodCount}</div>
      <div>기분 나쁜 일기 개수 : {badCount}</div>
      <div>기분 좋은 일기 비율 : {goodRatio}</div>
      <DiaryList diaryList={data} onRemove={onRemove} onEdit={onEdit} />
    </div>
  );
};
export default App;
```

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20(React%20js)%20be6a156c153f48049f84c633fc175ed7/Untitled%202.png)

콘솔에 일기 분석 시작이 2번 찍힘.

처음에 마운트될 때 getDataAnalysis 함수가 수행되어 콘솔에 1번 찍힌다.

api를 불러오고 setData함수가 호출되어 data의 값이 변하면 App 컴포넌트의 리렌더링이 일어나서 콘솔에 한 번 더 찍힌다.

what if? 일기의 내용을 수정한다면?

→ getDataAnalysis 함수가 또 호출되는 일이 발생 

emotion과 전혀 상관 없는 일기의 content가 바뀐 건데 App 컴포넌트의 리렌더링으로  getDataAnalysis가 한 번 더 실행됨.

⇒memoization 이 필요함.

의존성 배열의 값이 변할 때에만 함수가 다시 실행됨.

단계2> useMemo를 사용해서 최적화 (불필요한 연산 방지)

```jsx
import { useState, useRef, useEffect, useMemo } from "react";
import "./App.css";

import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

const App = () => {
  const [data, setData] = useState([]);

  const dataId = useRef(0);

  const getData = async () => {
    const res = await fetch(
      "https://jsonplaceholder.typicode.com/comments"
    ).then((res) => res.json());
    console.log(res);
    const initData = res.slice(0, 20).map((it) => {
      return {
        author: it.email,
        content: it.body,
        emotion: Math.floor(Math.random() * 5) + 1,
        created_date: new Date().getTime(),
        id: dataId.current++,
      };
    });
    setData(initData);
  };

  useEffect(() => {
    getData();
  }, []);

  const onCreate = (author, content, emotion) => {
    const created_date = new Date().getTime();
    const newItem = {
      author,
      content,
      emotion,
      created_date: created_date,
      id: dataId.current,
    };
    dataId.current += 1;
    setData([newItem, ...data]);
  };

  const onEdit = (targetId, newContent) => {
    setData(
      data.map((it) =>
        it.id === targetId ? { ...it, content: newContent } : it
      )
    );
  };

  const onRemove = (targetId) => {
    console.log(targetId);
    const newDiaryList = data.filter((it) => it.id !== targetId);
    setData(newDiaryList);
  };

  const getDiaryAnalysis = useMemo(() => {
    console.log("일기 분석 시작");

    const goodCount = data.filter((it) => it.emotion >= 3).length;
    const badCount = data.length - goodCount;
    const goodRatio = (goodCount / data.length) * 100;
    return { goodCount, badCount, goodRatio };
  }, [data.length]);

  const { goodCount, badCount, goodRatio } = getDiaryAnalysis; //getDiaryAnalysis()가 아님에 주의
  return (
    <div>
      <DiaryEditor onCreate={onCreate} />
      <div>전체 일기 : {data.length} </div>
      <div>기분 좋은 일기 개수 : {goodCount}</div>
      <div>기분 나쁜 일기 개수 : {badCount}</div>
      <div>기분 좋은 일기 비율 : {goodRatio}</div>
      <DiaryList diaryList={data} onRemove={onRemove} onEdit={onEdit} />
    </div>
  );
};
export default App;
```

최적화하고 싶은 (메모이제이션하고 싶은) 함수를 useMemo로 감싸고 의존성 배열에 적절한 값을 넣어준다. 의존성 배열에 넣어준 값이 변할 때만 연산이 다시 수행됨.

주의할 점은 useMemo는 callback 함수의 return값을 return하기 때문에 함수 형태로 값을 전달하면 안된다는 것이다.

## 최적화2 - 컴포넌트 재사용

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20(React%20js)%20be6a156c153f48049f84c633fc175ed7/Untitled%203.png)

위 사진과 같은 컴포넌트 트리가 있다고 가정. 

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20(React%20js)%20be6a156c153f48049f84c633fc175ed7/Untitled%204.png)

setCount(10)코드가 실행되면 state의 count가 바뀌고, state가 바뀌었기 때문에 App이 리렌더링 된다 → App의 자식 컴포넌트인 CountView와 TextView도 리렌더링

그러나 text만 prop으로 받는 TextView는 리렌더링 될 필요가 없음.

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20(React%20js)%20be6a156c153f48049f84c633fc175ed7/Untitled%205.png)

함수형 컴포넌트에 업데이트 조걸을 걸 수 있는 기능 = React.memo

**React.memo란?** - 고차 컴포넌트 ( 컴포넌트를 가져와서 새 컴포넌트를 반환하는 함수 ) 

똑같은 prop을 받으면 리렌더링하지 않음. (물론 자기 자신의 state가 바뀌면 리렌더링 됨, 오직 부모 component에 의한 리렌더만 React.memo에 의해 작동)

```jsx
const MyComponent = React.memeo(funciton MyComponent(props) {
});
```

최적화가 필요한 코드

```jsx
import { useState, useEffect } from "react";

const TextView = ({ text }) => {
  useEffect(() => {
    console.log(`Update :: Text : ${text}`);
  });
  return <div>{text}</div>;
};

const CountView = ({ count }) => {
  useEffect(() => {
    console.log(`Update :: Count : ${count}`);
  });
  return <div>{count}</div>;
};

const OptimizeTest = () => {
  const [count, setCount] = useState(1);
  const [text, setText] = useState("");

  return (
    <div style={{ padding: 50 }}>
      <div>
        <h2>count</h2>
        <CountView count={count} />
        <button onClick={() => setCount(count + 1)}>+</button>
      </div>
      <div>
        <h2>text</h2>
        <TextView text={text} />
        <input value={text} onChange={(e) => setText(e.target.value)} />
      </div>
    </div>
  );
};
export default OptimizeTest;
```

count 값이 변하거나 text 값이 변할 때마다 둘 중 어느 값이 변하던 상관 없이 콘솔에 count와 text의 값이 모두 찍힘.

⇒ React.memo 적용

```jsx
import React, { useState, useEffect } from "react";

const TextView = React.memo(({ text }) => {
  useEffect(() => {
    console.log(`Update :: Text : ${text}`);
  });
  return <div>{text}</div>;
});

const CountView = React.memo(({ count }) => {
  useEffect(() => {
    console.log(`Update :: Count : ${count}`);
  });
  return <div>{count}</div>;
});

const OptimizeTest = () => {
  const [count, setCount] = useState(1);
  const [text, setText] = useState("");

  return (
    <div style={{ padding: 50 }}>
      <div>
        <h2>count</h2>
        <CountView count={count} />
        <button onClick={() => setCount(count + 1)}>+</button>
      </div>
      <div>
        <h2>text</h2>
        <TextView text={text} />
        <input value={text} onChange={(e) => setText(e.target.value)} />
      </div>
    </div>
  );
};
export default OptimizeTest;
```

count의 값이 바뀌는 경우 console.log(`Update :: Count : ${count}`);만 실행되고,

text의 값이 바뀌는 경우 console.log(`Update :: Text : ${text}`);만 실행된다.

또 다른 실습 코드

```jsx
import React, { useState, useEffect } from "react";

const CounterA = React.memo(({ count }) => {
  useEffect(() => {
    console.log(`CounterA Updated - count: ${count}`);
  });
  return <div>{count}</div>;
});
const CounterB = React.memo(({ obj }) => {
  useEffect(() => {
    console.log(`CounterB Updated - count: ${obj.count}`);
  });
  return <div>{obj.count}</div>;
});

const OptimizeTest = () => {
  const [count, setCount] = useState(1);
  const [obj, setObj] = useState({ count: 1 });

  return (
    <div style={{ padding: 50 }}>
      <div>
        <h2>counter A</h2>
        <CounterA count={count} />
        <button
          onClick={() => {
            setCount(count);
          }}
        >
          A button
        </button>
      </div>
      <div>
        <h2>counter B</h2>
        <CounterB obj={obj} />
        <button
          onClick={() => {
            setObj({ count: obj.count });
          }}
        >
          B button
        </button>
      </div>
    </div>
  );
};
export default OptimizeTest;
```

A button을 눌러도 count (type : number)의 값이 변하지 않고 그대로 count기 때문에 콘솔에 아무 것도 찍히지 않음

But, B button도 마찬가지로 obj의 count 값은 변하지 않지만 콘솔에 `CounterB Updated - count: 1`이 찍힘. 

⇒ 객체와 같은 비원시타입의 자료형은 얕은 비교(주소에 의한 비교)를 하기 때문!

⇒ 객체를 prop으로 넘기는 경우, React.memo()에 비교함수를 파라미터로 넘겨서 위 문제를 해결할 수 있음

```jsx
import React, { useState, useEffect } from "react";

const CounterA = React.memo(({ count }) => {
  useEffect(() => {
    console.log(`CounterA Updated - count: ${count}`);
  });
  return <div>{count}</div>;
});
const CounterB = ({ obj }) => {
  useEffect(() => {
    console.log(`CounterB Updated - count: ${obj.count}`);
  });
  return <div>{obj.count}</div>;
};

const areEqual = (prevProps, nextProps) => {
  if (prevProps.obj.count === nextProps.obj.count) {
    return true; //이전 프롭과 현재 프롭이 같음 -> 리렌더링 x
  }
  return false; //이전 프롭과 현재 프롭이 다름 -> 리렌더링 ㅇ
};
const MemoizedCounterB = React.memo(CounterB, areEqual);

const OptimizeTest = () => {
  const [count, setCount] = useState(1);
  const [obj, setObj] = useState({ count: 1 });

  return (
    <div style={{ padding: 50 }}>
      <div>
        <h2>counter A</h2>
        <CounterA count={count} />
        <button
          onClick={() => {
            setCount(count);
          }}
        >
          A button
        </button>
      </div>
      <div>
        <h2>counter B</h2>
        <MemoizedCounterB obj={obj} />
        <button
          onClick={() => {
            setObj({ count: obj.count });
          }}
        >
          B button
        </button>
      </div>
    </div>
  );
};
export default OptimizeTest;
```

## 최적화3 - useCallback

단계 1> 어떤 컴포넌트가 최적화 대상인지 찾아내기

<aside>
💡 React Developer Tools 의 기능 이용 → 개발자도구 →컴포넌트 → 설정 → Highlight updates when components render 체크

</aside>

어떤 컴포넌트가 변동되고 있는지 깜빡여서 알려주는 기능

실습 코드에 적용 → DiaryList에서 일기를 삭제하면 DiaryEditor도 같이 깜빡임.

→최적화 대상

DiaryEditor를 최적화

```jsx
import { React, useRef, useState } from "react";

const DiaryEditor = ({ onCreate }) => {
	useEffect(() => {
    console.log("다이어리 에디터 렌더");
  });
  const authorInput = useRef();
  const contentInput = useRef();

  const [state, setState] = useState({
    author: "",
    content: "",
    emotion: 1,
  });

  const handleChangeState = (e) => {
    setState({ ...state, [e.target.name]: e.target.value });
  };

  const handleSubmit = () => {
    if (state.author.length < 1) {
      authorInput.current.focus();
      return;
    }
    if (state.content < 5) {
      contentInput.current.focus();
      return;
    }
    onCreate(state.author, state.content, state.emotion);
    alert("저장 완료");
    setState({ author: "", content: "", emotion: 1 });
  };

  return (
    <div className="DiaryEditor">
      <h2>오늘의 일기</h2>
      <div>
        <input
          ref={authorInput}
          name="author"
          value={state.author}
          onChange={handleChangeState}
        />
      </div>
      <div>
        <textarea
          ref={contentInput}
          name="content"
          value={state.content}
          onChange={handleChangeState}
        />
      </div>
      <div>
        <span>오늘의 감정 점수 : </span>
        <select
          name="emotion"
          value={state.emotion}
          onChange={handleChangeState}
        >
          <option value={1}>1</option>
          <option value={2}>2</option>
          <option value={3}>3</option>
          <option value={4}>4</option>
          <option value={5}>5</option>
        </select>
      </div>
      <div>
        <button onClick={handleSubmit}>일기 저장하기</button>
      </div>
    </div>
  );
};
export default React.memo(DiaryEditor); //굳이 위에서 긴 코드를 전부 묶지 않아도 됨. 
```

**단계 2> React.memo() 적용 후 렌더링 확인해보기**

콘솔에 ‘다이어리 에디터 렌더’가 2번 찍힘 = DiaryEditor가 두 번 렌더 됨 (최적화 x) 

→ App.js의 코드 확인

**컴포넌트가 렌더링되는 경우**

1. 본인이 가진 state의 값이 변하는 경우

2. 부모 컴포넌트가 리렌더링 되는 경우

3.자신이 받은 prop이 변경되는 경우

App 컴포넌트가 렌더링되면서 DiaryEditor도 렌더링 됨 (data가 빈 배열인 상태에서)

컴포넌트가 마운트되는 시점에 호출한 getData()함수에서 setData()함수가 실행되고, data state가 바뀌게 되면서 App컴포넌트가 렌더링 됨. 

⇒ App 컴포넌트가 마운트되자마자 2번의 렌더링이 일어나서 DiaryEditor의 prop으로 전달되는 onCreate함수도 다시 생성됨. onCreate 함수 안의 값들은 재생성되어도 똑같은 값을 갖지만, 비원시 타입 자료형이기 때문에 얕은 비교를 하게 되어, 렌더링이 일어나는 것.

결론: App 컴포넌트의 onCreate함수가 재생성되지 않아야 DiaryEditor를 React.memo로 최적화 할 수 있음.

→ onCreate가 재생성되지 않게하려 할 때 고려할 수 있는 방법 

1) **useMemo** → 그러나 useMemo는 dependency array를 기준으로 메모이제이션을 도와주는 기능이지만,  함수가 아니라 값을 반환하기 때문에 사용할 수 없음.

2)**useCallback** - 메모이제이션된 콜백함수를 반환.

```jsx
사용 방법
const memoizedCallback = useCallback(()=>{
	dosomething(a,b);
},
[a,b], //의존성 배열의 값이 변하지 않으면 콜백함수도 재생성되지 않음.
);
```

onCreate()에 useCallback 적용

```jsx
import { useState, useRef, useEffect, useMemo, useCallback } from "react";
import "./App.css";

import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

const App = () => {
  const [data, setData] = useState([]);

  const dataId = useRef(0);

  const getData = async () => {
    const res = await fetch(
      "https://jsonplaceholder.typicode.com/comments"
    ).then((res) => res.json());

    const initData = res.slice(0, 20).map((it) => {
      return {
        author: it.email,
        content: it.body,
        emotion: Math.floor(Math.random() * 5) + 1,
        created_date: new Date().getTime(),
        id: dataId.current++,
      };
    });
    setData(initData);
  };

  useEffect(() => {
    getData();
  }, []);

  const onCreate = useCallback((author, content, emotion) => {
    const created_date = new Date().getTime();
    const newItem = {
      author,
      content,
      emotion,
      created_date: created_date,
      id: dataId.current,
    };
    dataId.current += 1;
    setData([newItem, ...data]);
  },[]);

  const onEdit = (targetId, newContent) => {
    setData(
      data.map((it) =>
        it.id === targetId ? { ...it, content: newContent } : it
      )
    );
  };

  const onRemove = (targetId) => {
    const newDiaryList = data.filter((it) => it.id !== targetId);
    setData(newDiaryList);
  };

  const getDiaryAnalysis = useMemo(() => {
    const goodCount = data.filter((it) => it.emotion >= 3).length;
    const badCount = data.length - goodCount;
    const goodRatio = (goodCount / data.length) * 100;
    return { goodCount, badCount, goodRatio };
  }, [data.length]);

  const { goodCount, badCount, goodRatio } = getDiaryAnalysis;
  return (
    <div className="App">
      <DiaryEditor onCreate={onCreate} />
      <div>전체 일기 : {data.length} </div>
      <div>기분 좋은 일기 개수 : {goodCount}</div>
      <div>기분 나쁜 일기 개수 : {badCount}</div>
      <div>기분 좋은 일기 비율 : {goodRatio}</div>
      <DiaryList diaryList={data} onRemove={onRemove} onEdit={onEdit} />
    </div>
  );
};
export default App;
```

적용하고 새로운 일기를 작성하면 모든 일기가 사라지고 방금 작성한 일기만 존재함. 

→dependency array에 아무 값도 넣지 않아서

**문제 상황**

useCallback으로 감싼 onCreate함수는 컴포넌트가 마운트 되는 시점에 한번만 생성되고 그 당시 data state는 빈 배열임.  

컴포넌트가 리렌더링될 때 함수가 다시 생성되는 이유는 현재 state값을 참조하기 위해서인데 onCreate 함수는 콜백 안에 갇혀서 현재의 data state를 참조하지 못하고 빈 배열을 전달 함. 

**고려할 수 있는 해결 방법**

1) 의존성 배열에 data 전달 

그러나, data 값이 바뀌면 함수가 재생성되기 때문에 결론적으로 원하는 동작을 할 수 없음

data가 바뀌어도 onCreate()가 재생성되지 않길 바람. 그러나 onCreate()가 재생성되지 않으면 최신의 data state값을 가져올 수 없어서 이상한 동작을 하게 됨. →딜레마

2)함수형 업데이트 사용.  

함수형 업데이트는 상태 변화 함수에 함수를 전달하는 것

→화살표 함수의 전달 인자로 data를 주고 아이템을 추가한  data를 반환하는 콜백을 setData에 전달

→ dependency array를 비워도 항상 최신의 state를 인자를 통해 참고할 수 있어서 deps를 비울 수 있음.

```jsx
import { useState, useRef, useEffect, useMemo, useCallback } from "react";
import "./App.css";

import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

const App = () => {
  const [data, setData] = useState([]);

  const dataId = useRef(0);

  const getData = async () => {
    const res = await fetch(
      "https://jsonplaceholder.typicode.com/comments"
    ).then((res) => res.json());

    const initData = res.slice(0, 20).map((it) => {
      return {
        author: it.email,
        content: it.body,
        emotion: Math.floor(Math.random() * 5) + 1,
        created_date: new Date().getTime(),
        id: dataId.current++,
      };
    });
    setData(initData);
  };

  useEffect(() => {
    getData();
  }, []);

  const onCreate = useCallback((author, content, emotion) => {
    const created_date = new Date().getTime();
    const newItem = {
      author,
      content,
      emotion,
      created_date: created_date,
      id: dataId.current,
    };
    dataId.current += 1;
    setData((data) => [newItem, ...data]);
  }, []);

  const onEdit = (targetId, newContent) => {
    setData(
      data.map((it) =>
        it.id === targetId ? { ...it, content: newContent } : it
      )
    );
  };

  const onRemove = (targetId) => {
    const newDiaryList = data.filter((it) => it.id !== targetId);
    setData(newDiaryList);
  };

  const getDiaryAnalysis = useMemo(() => {
    const goodCount = data.filter((it) => it.emotion >= 3).length;
    const badCount = data.length - goodCount;
    const goodRatio = (goodCount / data.length) * 100;
    return { goodCount, badCount, goodRatio };
  }, [data.length]);

  const { goodCount, badCount, goodRatio } = getDiaryAnalysis;
  return (
    <div className="App">
      <DiaryEditor onCreate={onCreate} />
      <div>전체 일기 : {data.length} </div>
      <div>기분 좋은 일기 개수 : {goodCount}</div>
      <div>기분 나쁜 일기 개수 : {badCount}</div>
      <div>기분 좋은 일기 비율 : {goodRatio}</div>
      <DiaryList diaryList={data} onRemove={onRemove} onEdit={onEdit} />
    </div>
  );
};
export default App;
```

정리> 불필요한 렌더링이 일어나는 것 확인 → DiaryEditor를 React.memo()로 메모이제이션→ prop으로 전달한 onCreate()함수가 재생성되기 때문에 React.memo()로 메모이제이션한 효과를 볼 수 없었음 → onCreate()함수를 최적화하기 위해 useCallback을 사용했으나 현재 data state를반영하지 못하는 문제 발생 → 함수형 업데이트로 해결

## 최적화4 - 최적화 완성

그동안 최적화 기술을 응용해 프로젝트 전반을 최적화 

1> DiaryItem 하나만 삭제해도 나머지 Item들이 다 리렌더링

리렌더되는 것 확인하는 코드

```jsx
import React, { useState, useRef, useEffect } from "react";

const DiaryItem = ({
  id,
  author,
  content,
  emotion,
  created_date,
  onRemove,
  onEdit,
}) => {
  useEffect(() => {
    console.log(`${id}번째 아이템 렌더!`);
  });
  const localContentInput = useRef();

  const [isEdit, setIsEdit] = useState(false);
  const [localContent, setLocalContent] = useState(content);

  const handleRemove = () => {
    if (window.confirm(`${id}번째 일기를 삭제하시겠습니까?`)) {
      onRemove(id);
    }
  };

  const toggleIsEdit = () => {
    setIsEdit(!isEdit);
  };

  const HandleQuitEdit = () => {
    setIsEdit(false);
    setLocalContent(content);
  };

  const handleEdit = () => {
    if (localContent.length < 5) {
      localContentInput.current.focus();
      return;
    }
    if (window.confirm(`${id}번째 일기를 수정하시겠습니까?`)) {
      onEdit(id, localContent);
      toggleIsEdit();
    }
  };

  return (
    <div className="DiaryItem">
      <div className="Info">
        <span>
          작성자 : {author} | 감정 점수 : {emotion} |
        </span>
        <br />
        <div className="Date">
          작성된 날짜 : {new Date(created_date).toLocaleString()}
        </div>
      </div>
      <div className="Content">
        {isEdit ? (
          <textarea
            ref={localContentInput}
            value={localContent}
            onChange={(e) => {
              setLocalContent(e.target.value);
            }}
          />
        ) : (
          content
        )}
      </div>
      <div>
        {isEdit ? (
          <>
            <button onClick={HandleQuitEdit}>수정 취소</button>
            <button onClick={handleEdit}>수정 완료</button>
          </>
        ) : (
          <>
            <button onClick={handleRemove}>삭제하기</button>
            <button onClick={toggleIsEdit}>수정하기</button>
          </>
        )}
      </div>
    </div>
  );
};
export default React.memo(DiaryItem);
```

콘솔에 id가 0부터 19인 아이템이 다시 렌더링 됨.

DiaryItem이 받는 prop은 onEdit, onRemove, id, author, content, emotion, created_date인데 content, onEdit,onRemove를 제외한 나머지 prop은 변하지 않는 값

onEdit과 onRemove는 onCreate를 최적화한 것과 같은 방법으로 최적화

```jsx
import { useState, useRef, useEffect, useMemo, useCallback } from "react";
import "./App.css";

import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

const App = () => {
  const [data, setData] = useState([]);

  const dataId = useRef(0);

  const getData = async () => {
    const res = await fetch(
      "https://jsonplaceholder.typicode.com/comments"
    ).then((res) => res.json());

    const initData = res.slice(0, 20).map((it) => {
      return {
        author: it.email,
        content: it.body,
        emotion: Math.floor(Math.random() * 5) + 1,
        created_date: new Date().getTime(),
        id: dataId.current++,
      };
    });
    setData(initData);
  };

  useEffect(() => {
    setTimeout(() => {
      getData();
    }, 1500);
  }, []);

  const onCreate = useCallback((author, content, emotion) => {
    const created_date = new Date().getTime();
    const newItem = {
      author,
      content,
      emotion,
      created_date: created_date,
      id: dataId.current,
    };
    dataId.current += 1;
    setData((data) => [newItem, ...data]);
  }, []);

  const onEdit = useCallback((targetId, newContent) => {
    setData((data) =>
      data.map((it) =>
        it.id === targetId ? { ...it, content: newContent } : it
      )
    );
  }, []);

  const onRemove = useCallback((targetId) => {
    setData(data.filter((it) => it.id !== targetId));
  });

  const getDiaryAnalysis = useMemo(() => {
    const goodCount = data.filter((it) => it.emotion >= 3).length;
    const badCount = data.length - goodCount;
    const goodRatio = (goodCount / data.length) * 100;
    return { goodCount, badCount, goodRatio };
  }, [data.length]);

  const { goodCount, badCount, goodRatio } = getDiaryAnalysis;
  return (
    <div className="App">
      <DiaryEditor onCreate={onCreate} />
      <div>전체 일기 : {data.length} </div>
      <div>기분 좋은 일기 개수 : {goodCount}</div>
      <div>기분 나쁜 일기 개수 : {badCount}</div>
      <div>기분 좋은 일기 비율 : {goodRatio}</div>
      <DiaryList diaryList={data} onRemove={onRemove} onEdit={onEdit} />
    </div>
  );
};
export default App;
```

콘솔로 확인→방금 추가한 아이템만 렌더링됨.

## 복잡한 상태 관리 로직 분리하기 - useReducer

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20(React%20js)%20be6a156c153f48049f84c633fc175ed7/Untitled%206.png)

App 컴포넌트의 상태관리 로직이 제일 복잡했음.

*상태 변화 함수들은 상태를 update하기 위해선 기존의 state를 참조해야했기 때문에 컴포넌트 내에만 존재해야 했음.*

컴포넌트 내 코드가 길어지고 무거워지는 것은 좋지 않음. 

useReducer = 상태변화 로직을 컴포넌트에서 분리하는 기능

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20(React%20js)%20be6a156c153f48049f84c633fc175ed7/Untitled%207.png)

이 코드를 아래와 같이 변경

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20(React%20js)%20be6a156c153f48049f84c633fc175ed7/Untitled%208.png)

useReducer기능을 통해 컴포넌트 외부로 상태 변화로직을 분리하여마치 switch-case문처럼 사용 할 수 있음.

<aside>
💡 useReducer를 사용할 땐 비구조화 할당, 배열의 첫번째 값은 state, 두번째 값은 꼭 dispatch로 전달해야 함. 그리고 () 안에는 reducer와 초기 상태를 전달한다.

</aside>

App.js에 적용해보기

```jsx
import { useRef, useEffect, useMemo, useCallback, useReducer } from "react";
import "./App.css";

import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

const reducer = (state, action) => {
  switch (action.type) {
    case "INIT": {
      return action.data;
    }
    case "CREATE": {
      const created_date = new Date().getTime();
      const newItem = {
        ...action.data,
        created_date,
      };
      return [newItem, ...state];
    }
    case "REMOVE": {
      return state.filter((it) => it.id !== action.targetId);
    }
    case "EDIT": {
      return state.map((it) =>
        it.id === action.targetId ? { ...it, content: action.newContent } : it
      );
    }
    default:
      return state;
  }
};

const App = () => {
  //const [data, setData] = useState([]);
  const [data, dispatch] = useReducer(reducer, []);

  const dataId = useRef(0);

  const getData = async () => {
    const res = await fetch(
      "https://jsonplaceholder.typicode.com/comments"
    ).then((res) => res.json());

    const initData = res.slice(0, 20).map((it) => {
      return {
        author: it.email,
        content: it.body,
        emotion: Math.floor(Math.random() * 5) + 1,
        created_date: new Date().getTime(),
        id: dataId.current++,
      };
    });
    dispatch({ type: "INIT", data: initData });
  };

  useEffect(() => {
    setTimeout(() => {
      getData();
    }, 1500);
  }, []);

  const onCreate = useCallback((author, content, emotion) => {
    dispatch({
      type: "CREATE",
      data: { author, content, emotion, id: dataId.current },
    });

    dataId.current += 1;
  }, []);

  const onEdit = useCallback((targetId, newContent) => {
    dispatch({ type: "EDIT", targetId, newContent });
  }, []);

  const onRemove = useCallback((targetId) => {
    dispatch({ type: "REMOVE", targetId });
  });

  const getDiaryAnalysis = useMemo(() => {
    const goodCount = data.filter((it) => it.emotion >= 3).length;
    const badCount = data.length - goodCount;
    const goodRatio = (goodCount / data.length) * 100.0;
    return { goodCount, badCount, goodRatio };
  }, [data.length]);

  const { goodCount, badCount, goodRatio } = getDiaryAnalysis;
  return (
    <div className="App">
      <DiaryEditor onCreate={onCreate} />
      <div>전체 일기 : {data.length} </div>
      <div>기분 좋은 일기 개수 : {goodCount}</div>
      <div>기분 나쁜 일기 개수 : {badCount}</div>
      <div>기분 좋은 일기 비율 : {goodRatio}</div>
      <DiaryList diaryList={data} onRemove={onRemove} onEdit={onEdit} />
    </div>
  );
};
export default App;
```

주의) switch-case에는 반드시 default case를 적어줘야 함.  reducer는 항상 새로운 상태를 반환해줘야 함. 

useReducer 함수를 이용할 때 상태 변화를 일으키는 함수를 dispatch로 썼었는데 dispatch는함수형 업데이트 필요없이 현재 state를 자동으로 참조하기 때문에 useCallback의 의존성배열을 걱정하지 않아도 됨.

## 컴포넌트 트리에 데이터 공급하기 - Context

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20(React%20js)%20be6a156c153f48049f84c633fc175ed7/Untitled%209.png)

프로젝트의 컴포넌트 트리

단방향 데이터 흐름 때문에 props drilling 문제 발생 

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20(React%20js)%20be6a156c153f48049f84c633fc175ed7/Untitled%2010.png)

Provider 컴포넌트를 생성하면 직통으로 prop을 전달할 수 있음.

⇒Context 이용 

![Untitled](%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B5%E1%86%B8%20%E1%84%8F%E1%85%B3%E1%84%80%E1%85%B5%E1%84%85%E1%85%A9%20%E1%84%8C%E1%85%A1%E1%86%AF%E1%84%85%E1%85%A1%E1%84%86%E1%85%A5%E1%86%A8%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%85%E1%85%B5%E1%84%8B%E1%85%A2%E1%86%A8%E1%84%90%E1%85%B3%20(React%20js)%20be6a156c153f48049f84c633fc175ed7/Untitled%2011.png)

단계 1> Context 생성하고 Provider로 데이터 공급하기

```jsx
import React, {
  useRef,
  useEffect,
  useMemo,
  useCallback,
  useReducer,
} from "react";
import "./App.css";

import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

const reducer = (state, action) => {
  switch (action.type) {
    case "INIT": {
      return action.data;
    }
    case "CREATE": {
      const created_date = new Date().getTime();
      const newItem = {
        ...action.data,
        created_date,
      };
      return [newItem, ...state];
    }
    case "REMOVE": {
      return state.filter((it) => it.id !== action.targetId);
    }
    case "EDIT": {
      return state.map((it) =>
        it.id === action.targetId ? { ...it, content: action.newContent } : it
      );
    }
    default:
      return state;
  }
};

export const DiaryStateContext = React.createContext();

const App = () => {
  //const [data, setData] = useState([]);
  const [data, dispatch] = useReducer(reducer, []);

  const dataId = useRef(0);

  const getData = async () => {
    const res = await fetch(
      "https://jsonplaceholder.typicode.com/comments"
    ).then((res) => res.json());

    const initData = res.slice(0, 20).map((it) => {
      return {
        author: it.email,
        content: it.body,
        emotion: Math.floor(Math.random() * 5) + 1,
        created_date: new Date().getTime(),
        id: dataId.current++,
      };
    });
    dispatch({ type: "INIT", data: initData });
  };

  useEffect(() => {
    setTimeout(() => {
      getData();
    }, 1500);
  }, []);

  const onCreate = useCallback((author, content, emotion) => {
    dispatch({
      type: "CREATE",
      data: { author, content, emotion, id: dataId.current },
    });

    dataId.current += 1;
  }, []);

  const onEdit = useCallback((targetId, newContent) => {
    dispatch({ type: "EDIT", targetId, newContent });
  }, []);

  const onRemove = useCallback((targetId) => {
    dispatch({ type: "REMOVE", targetId });
  }, []);

  const getDiaryAnalysis = useMemo(() => {
    const goodCount = data.filter((it) => it.emotion >= 3).length;
    const badCount = data.length - goodCount;
    const goodRatio = (goodCount / data.length) * 100.0;
    return { goodCount, badCount, goodRatio };
  }, [data.length]);

  const { goodCount, badCount, goodRatio } = getDiaryAnalysis;
  return (
    <DiaryStateContext.Provider value={data}>
      <div className="App">
        <DiaryEditor onCreate={onCreate} />
        <div>전체 일기 : {data.length} </div>
        <div>기분 좋은 일기 개수 : {goodCount}</div>
        <div>기분 나쁜 일기 개수 : {badCount}</div>
        <div>기분 좋은 일기 비율 : {goodRatio}</div>
        <DiaryList diaryList={diaryList} onRemove={onRemove} onEdit={onEdit} />
      </div>
    </DiaryStateContext.Provider>
  );
};
export default App;
```

context를 export해줘야 함.

export default는 파일 하나당 하나만 쓸 수 있지만 export는 여러 개 쓸 수 있음. 

import하는 기능들 중에서 React는 중괄호 없이 React만 import하지만 다른 훅들은 비구조화할당을 통해서 import함 

React는 export default로 내보냈고, 나머지 훅들은 export const로 내보냈기 때문

DiaryList의 코드도 수정

```jsx
import { useContext } from "react";
import DiaryItem from "./DiaryItem";
import { DiaryStateContext } from "./App";

const DiaryList = ({ onRemove, onEdit }) => {
  const diaryList = useContext(DiaryStateContext);
  return (
    <div className="DiaryList">
      <h2>일기 리스트</h2>
      <h4>{diaryList.length}개의 일기가 있습니다.</h4>
      <div>
        {diaryList.map((it) => (
          <DiaryItem key={it.id} {...it} onRemove={onRemove} onEdit={onEdit} />
        ))}
      </div>
    </div>
  );
};

DiaryList.defaultProps = { diaryList: [] };
export default DiaryList;
```

먼저, useContext 훅 import하고, diaryList를 prop이 아닌 컴포넌트의 내부의 상수로 초기화

DiaryStateContext도 import해줘야 함.

이후에 App.js의 코드 중 diaryList를 prop으로 넘겨주는 부분을  수정해야 함.

```jsx
import React, {
  useRef,
  useEffect,
  useMemo,
  useCallback,
  useReducer,
} from "react";
import "./App.css";

import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

const reducer = (state, action) => {
  switch (action.type) {
    case "INIT": {
      return action.data;
    }
    case "CREATE": {
      const created_date = new Date().getTime();
      const newItem = {
        ...action.data,
        created_date,
      };
      return [newItem, ...state];
    }
    case "REMOVE": {
      return state.filter((it) => it.id !== action.targetId);
    }
    case "EDIT": {
      return state.map((it) =>
        it.id === action.targetId ? { ...it, content: action.newContent } : it
      );
    }
    default:
      return state;
  }
};

export const DiaryStateContext = React.createContext();

const App = () => {
  //const [data, setData] = useState([]);
  const [data, dispatch] = useReducer(reducer, []);

  const dataId = useRef(0);

  const getData = async () => {
    const res = await fetch(
      "https://jsonplaceholder.typicode.com/comments"
    ).then((res) => res.json());

    const initData = res.slice(0, 20).map((it) => {
      return {
        author: it.email,
        content: it.body,
        emotion: Math.floor(Math.random() * 5) + 1,
        created_date: new Date().getTime(),
        id: dataId.current++,
      };
    });
    dispatch({ type: "INIT", data: initData });
  };

  useEffect(() => {
    setTimeout(() => {
      getData();
    }, 1500);
  }, []);

  const onCreate = useCallback((author, content, emotion) => {
    dispatch({
      type: "CREATE",
      data: { author, content, emotion, id: dataId.current },
    });

    dataId.current += 1;
  }, []);

  const onEdit = useCallback((targetId, newContent) => {
    dispatch({ type: "EDIT", targetId, newContent });
  }, []);

  const onRemove = useCallback((targetId) => {
    dispatch({ type: "REMOVE", targetId });
  }, []);

  const getDiaryAnalysis = useMemo(() => {
    const goodCount = data.filter((it) => it.emotion >= 3).length;
    const badCount = data.length - goodCount;
    const goodRatio = (goodCount / data.length) * 100.0;
    return { goodCount, badCount, goodRatio };
  }, [data.length]);

  const { goodCount, badCount, goodRatio } = getDiaryAnalysis;
  return (
    <DiaryStateContext.Provider value={data}>
      <div className="App">
        <DiaryEditor onCreate={onCreate} />
        <div>전체 일기 : {data.length} </div>
        <div>기분 좋은 일기 개수 : {goodCount}</div>
        <div>기분 나쁜 일기 개수 : {badCount}</div>
        <div>기분 좋은 일기 비율 : {goodRatio}</div>
        <DiaryList onRemove={onRemove} onEdit={onEdit} />
      </div>
    </DiaryStateContext.Provider>
  );
};
export default App;
```

그렇다면 onCreate, onEdit, onRemove도 Provider를 통해서 prop으로 내려줄 수 있을까?

⇒ Provider 또한 컴포넌트기 때문에 prop이 바뀌면 Provider 컴포넌트가 재생성되고, 이렇게 되면 밑에 있는 컴포넌트들 또한 재생성되는 문제가 생김 (만들어두었던 최적화가 다 풀리게 됨)

→Context를 중첩해서 사용

```jsx
import React, {
  useRef,
  useEffect,
  useMemo,
  useCallback,
  useReducer,
} from "react";
import "./App.css";

import DiaryEditor from "./DiaryEditor";
import DiaryList from "./DiaryList";

const reducer = (state, action) => {
  switch (action.type) {
    case "INIT": {
      return action.data;
    }
    case "CREATE": {
      const created_date = new Date().getTime();
      const newItem = {
        ...action.data,
        created_date,
      };
      return [newItem, ...state];
    }
    case "REMOVE": {
      return state.filter((it) => it.id !== action.targetId);
    }
    case "EDIT": {
      return state.map((it) =>
        it.id === action.targetId ? { ...it, content: action.newContent } : it
      );
    }
    default:
      return state;
  }
};

export const DiaryStateContext = React.createContext();
export const DiaryDispatchContext = React.createContext();

const App = () => {
  //const [data, setData] = useState([]);
  const [data, dispatch] = useReducer(reducer, []);

  const dataId = useRef(0);

  const getData = async () => {
    const res = await fetch(
      "https://jsonplaceholder.typicode.com/comments"
    ).then((res) => res.json());

    const initData = res.slice(0, 20).map((it) => {
      return {
        author: it.email,
        content: it.body,
        emotion: Math.floor(Math.random() * 5) + 1,
        created_date: new Date().getTime(),
        id: dataId.current++,
      };
    });
    dispatch({ type: "INIT", data: initData });
  };

  useEffect(() => {
    setTimeout(() => {
      getData();
    }, 1500);
  }, []);

  const onCreate = useCallback((author, content, emotion) => {
    dispatch({
      type: "CREATE",
      data: { author, content, emotion, id: dataId.current },
    });

    dataId.current += 1;
  }, []);

  const onEdit = useCallback((targetId, newContent) => {
    dispatch({ type: "EDIT", targetId, newContent });
  }, []);

  const onRemove = useCallback((targetId) => {
    dispatch({ type: "REMOVE", targetId });
  }, []);

  const memoizedDispatches = useMemo(() => {
    return { onCreate, onEdit, onRemove };
  }, []); //useMemo로 감싸지 않으면 App 컴포넌트가 재생성될 때 {onCreate,onEdit,onRemove}도 재생성되기 때문

  const getDiaryAnalysis = useMemo(() => {
    const goodCount = data.filter((it) => it.emotion >= 3).length;
    const badCount = data.length - goodCount;
    const goodRatio = (goodCount / data.length) * 100.0;
    return { goodCount, badCount, goodRatio };
  }, [data.length]);

  const { goodCount, badCount, goodRatio } = getDiaryAnalysis;
  return (
    <DiaryStateContext.Provider value={data}>
      <DiaryDispatchContext.Provider value={memoizedDispatches}>
        <div className="App">
          <DiaryEditor />
          <div>전체 일기 : {data.length} </div>
          <div>기분 좋은 일기 개수 : {goodCount}</div>
          <div>기분 나쁜 일기 개수 : {badCount}</div>
          <div>기분 좋은 일기 비율 : {goodRatio}</div>
          <DiaryList />
        </div>
      </DiaryDispatchContext.Provider>
    </DiaryStateContext.Provider>
  );
};
export default App;
```

이제, DiaryEditor와 DiaryList, DiaryItem도 수정

```jsx
import React, { useRef, useState, useContext } from "react";
import { DiaryDispatchContext } from "./App";

const DiaryEditor = () => {
  const { onCreate } = useContext(DiaryDispatchContext);

  const authorInput = useRef();
  const contentInput = useRef();

  const [state, setState] = useState({
    author: "",
    content: "",
    emotion: 1,
  });

  const handleChangeState = (e) => {
    setState({ ...state, [e.target.name]: e.target.value });
  };

  const handleSubmit = () => {
    if (state.author.length < 1) {
      authorInput.current.focus();
      return;
    }
    if (state.content < 5) {
      contentInput.current.focus();
      return;
    }
    onCreate(state.author, state.content, state.emotion);
    alert("저장 완료");
    setState({ author: "", content: "", emotion: 1 });
  };

  return (
    <div className="DiaryEditor">
      <h2>오늘의 일기</h2>
      <div>
        <input
          ref={authorInput}
          name="author"
          value={state.author}
          onChange={handleChangeState}
          placeholder="작성자"
          type="text"
        />
      </div>
      <div>
        <textarea
          ref={contentInput}
          name="content"
          value={state.content}
          onChange={handleChangeState}
          placeholder="일기"
          type="text"
        />
      </div>
      <div>
        <span>오늘의 감정 점수 : </span>
        <select
          name="emotion"
          value={state.emotion}
          onChange={handleChangeState}
        >
          <option value={1}>1</option>
          <option value={2}>2</option>
          <option value={3}>3</option>
          <option value={4}>4</option>
          <option value={5}>5</option>
        </select>
      </div>
      <div>
        <button onClick={handleSubmit}>일기 저장하기</button>
      </div>
    </div>
  );
};
export default React.memo(DiaryEditor);
```

```jsx
import { useContext } from "react";
import DiaryItem from "./DiaryItem";
import { DiaryStateContext } from "./App";

const DiaryList = () => {
  const diaryList = useContext(DiaryStateContext);

  return (
    <div className="DiaryList">
      <h2>일기 리스트</h2>
      <h4>{diaryList.length}개의 일기가 있습니다.</h4>
      <div>
        {diaryList.map((it) => (
          <DiaryItem key={it.id} {...it} />
        ))}
      </div>
    </div>
  );
};

DiaryList.defaultProps = { diaryList: [] };
export default DiaryList;
```

```jsx
import React, { useState, useRef, useContext } from "react";
import { DiaryDispatchContext } from "./App";

const DiaryItem = ({ id, author, content, emotion, created_date }) => {
  const { onEdit, onRemove } = useContext(DiaryDispatchContext);

  const localContentInput = useRef();

  const [isEdit, setIsEdit] = useState(false);
  const [localContent, setLocalContent] = useState(content);

  const handleRemove = () => {
    if (window.confirm(`${id}번째 일기를 삭제하시겠습니까?`)) {
      onRemove(id);
    }
  };

  const toggleIsEdit = () => {
    setIsEdit(!isEdit);
  };

  const HandleQuitEdit = () => {
    setIsEdit(false);
    setLocalContent(content);
  };

  const handleEdit = () => {
    if (localContent.length < 5) {
      localContentInput.current.focus();
      return;
    }
    if (window.confirm(`${id}번째 일기를 수정하시겠습니까?`)) {
      onEdit(id, localContent);
      toggleIsEdit();
    }
  };

  return (
    <div className="DiaryItem">
      <div className="Info">
        <span>
          작성자 : {author} | 감정 점수 : {emotion} |
        </span>
        <br />
        <div className="Date">
          작성된 날짜 : {new Date(created_date).toLocaleString()}
        </div>
      </div>
      <div className="Content">
        {isEdit ? (
          <textarea
            ref={localContentInput}
            value={localContent}
            onChange={(e) => {
              setLocalContent(e.target.value);
            }}
          />
        ) : (
          content
        )}
      </div>
      <div>
        {isEdit ? (
          <>
            <button onClick={HandleQuitEdit}>수정 취소</button>
            <button onClick={handleEdit}>수정 완료</button>
          </>
        ) : (
          <>
            <button onClick={handleRemove}>삭제하기</button>
            <button onClick={toggleIsEdit}>수정하기</button>
          </>
        )}
      </div>
    </div>
  );
};
export default React.memo(DiaryItem);
```